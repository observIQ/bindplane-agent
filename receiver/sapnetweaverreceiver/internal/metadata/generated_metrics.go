// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"fmt"
	"strconv"
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/confmap"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`

	enabledProvidedByUser bool
}

// IsEnabledProvidedByUser returns true if `enabled` option is explicitly set in user settings to any value.
func (ms *MetricSettings) IsEnabledProvidedByUser() bool {
	return ms.enabledProvidedByUser
}

func (ms *MetricSettings) Unmarshal(parser *confmap.Conf) error {
	if parser == nil {
		return nil
	}
	err := parser.Unmarshal(ms, confmap.WithErrorUnused())
	if err != nil {
		return err
	}
	ms.enabledProvidedByUser = parser.IsSet("enabled")
	return nil
}

// MetricsSettings provides settings for sapnetweaverreceiver metrics.
type MetricsSettings struct {
	SapnetweaverHostCPUUtilization        MetricSettings `mapstructure:"sapnetweaver.host.cpu_utilization"`
	SapnetweaverHostMemoryVirtualOverhead MetricSettings `mapstructure:"sapnetweaver.host.memory.virtual.overhead"`
	SapnetweaverHostMemoryVirtualSwap     MetricSettings `mapstructure:"sapnetweaver.host.memory.virtual.swap"`
	SapnetweaverHostSpoolListUsed         MetricSettings `mapstructure:"sapnetweaver.host.spool_list.used"`
	SapnetweaverIcmAvailability           MetricSettings `mapstructure:"sapnetweaver.icm_availability"`
	SapnetweaverLocksEnqueueCount         MetricSettings `mapstructure:"sapnetweaver.locks.enqueue.count"`
	SapnetweaverSessionsBrowserCount      MetricSettings `mapstructure:"sapnetweaver.sessions.browser.count"`
	SapnetweaverSessionsEjbCount          MetricSettings `mapstructure:"sapnetweaver.sessions.ejb.count"`
	SapnetweaverSessionsHTTPCount         MetricSettings `mapstructure:"sapnetweaver.sessions.http.count"`
	SapnetweaverSessionsSecurityCount     MetricSettings `mapstructure:"sapnetweaver.sessions.security.count"`
	SapnetweaverSessionsWebCount          MetricSettings `mapstructure:"sapnetweaver.sessions.web.count"`
	SapnetweaverShortDumpsRate            MetricSettings `mapstructure:"sapnetweaver.short_dumps.rate"`
	SapnetweaverWorkProcessesActiveCount  MetricSettings `mapstructure:"sapnetweaver.work_processes.active.count"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		SapnetweaverHostCPUUtilization: MetricSettings{
			Enabled: true,
		},
		SapnetweaverHostMemoryVirtualOverhead: MetricSettings{
			Enabled: true,
		},
		SapnetweaverHostMemoryVirtualSwap: MetricSettings{
			Enabled: true,
		},
		SapnetweaverHostSpoolListUsed: MetricSettings{
			Enabled: true,
		},
		SapnetweaverIcmAvailability: MetricSettings{
			Enabled: true,
		},
		SapnetweaverLocksEnqueueCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverSessionsBrowserCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverSessionsEjbCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverSessionsHTTPCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverSessionsSecurityCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverSessionsWebCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverShortDumpsRate: MetricSettings{
			Enabled: true,
		},
		SapnetweaverWorkProcessesActiveCount: MetricSettings{
			Enabled: true,
		},
	}
}

// AttributeControlState specifies the a value control_state attribute.
type AttributeControlState int

const (
	_ AttributeControlState = iota
	AttributeControlStateGrey
	AttributeControlStateGreen
	AttributeControlStateYellow
	AttributeControlStateRed
)

// String returns the string representation of the AttributeControlState.
func (av AttributeControlState) String() string {
	switch av {
	case AttributeControlStateGrey:
		return "grey"
	case AttributeControlStateGreen:
		return "green"
	case AttributeControlStateYellow:
		return "yellow"
	case AttributeControlStateRed:
		return "red"
	}
	return ""
}

// MapAttributeControlState is a helper map of string to AttributeControlState attribute value.
var MapAttributeControlState = map[string]AttributeControlState{
	"grey":   AttributeControlStateGrey,
	"green":  AttributeControlStateGreen,
	"yellow": AttributeControlStateYellow,
	"red":    AttributeControlStateRed,
}

type metricSapnetweaverHostCPUUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.host.cpu_utilization metric with initial data.
func (m *metricSapnetweaverHostCPUUtilization) init() {
	m.data.SetName("sapnetweaver.host.cpu_utilization")
	m.data.SetDescription("CPU Utilization Percentage.")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSapnetweaverHostCPUUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverHostCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverHostCPUUtilization) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverHostCPUUtilization(settings MetricSettings) metricSapnetweaverHostCPUUtilization {
	m := metricSapnetweaverHostCPUUtilization{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverHostMemoryVirtualOverhead struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.host.memory.virtual.overhead metric with initial data.
func (m *metricSapnetweaverHostMemoryVirtualOverhead) init() {
	m.data.SetName("sapnetweaver.host.memory.virtual.overhead")
	m.data.SetDescription("Virtualization System Memory Overhead.")
	m.data.SetUnit("bytes")
	m.data.SetEmptyGauge()
}

func (m *metricSapnetweaverHostMemoryVirtualOverhead) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverHostMemoryVirtualOverhead) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverHostMemoryVirtualOverhead) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverHostMemoryVirtualOverhead(settings MetricSettings) metricSapnetweaverHostMemoryVirtualOverhead {
	m := metricSapnetweaverHostMemoryVirtualOverhead{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverHostMemoryVirtualSwap struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.host.memory.virtual.swap metric with initial data.
func (m *metricSapnetweaverHostMemoryVirtualSwap) init() {
	m.data.SetName("sapnetweaver.host.memory.virtual.swap")
	m.data.SetDescription("Virtualization System Swap Memory.")
	m.data.SetUnit("bytes")
	m.data.SetEmptyGauge()
}

func (m *metricSapnetweaverHostMemoryVirtualSwap) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverHostMemoryVirtualSwap) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverHostMemoryVirtualSwap) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverHostMemoryVirtualSwap(settings MetricSettings) metricSapnetweaverHostMemoryVirtualSwap {
	m := metricSapnetweaverHostMemoryVirtualSwap{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverHostSpoolListUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.host.spool_list.used metric with initial data.
func (m *metricSapnetweaverHostSpoolListUsed) init() {
	m.data.SetName("sapnetweaver.host.spool_list.used")
	m.data.SetDescription("Host Spool List Used.")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverHostSpoolListUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverHostSpoolListUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverHostSpoolListUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverHostSpoolListUsed(settings MetricSettings) metricSapnetweaverHostSpoolListUsed {
	m := metricSapnetweaverHostSpoolListUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverIcmAvailability struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.icm_availability metric with initial data.
func (m *metricSapnetweaverIcmAvailability) init() {
	m.data.SetName("sapnetweaver.icm_availability")
	m.data.SetDescription("ICM Availability (color value from alert tree).")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSapnetweaverIcmAvailability) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, controlStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("state", controlStateAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverIcmAvailability) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverIcmAvailability) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverIcmAvailability(settings MetricSettings) metricSapnetweaverIcmAvailability {
	m := metricSapnetweaverIcmAvailability{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverLocksEnqueueCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.locks.enqueue.count metric with initial data.
func (m *metricSapnetweaverLocksEnqueueCount) init() {
	m.data.SetName("sapnetweaver.locks.enqueue.count")
	m.data.SetDescription("Count of Enqueued Locks.")
	m.data.SetUnit("{locks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverLocksEnqueueCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverLocksEnqueueCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverLocksEnqueueCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverLocksEnqueueCount(settings MetricSettings) metricSapnetweaverLocksEnqueueCount {
	m := metricSapnetweaverLocksEnqueueCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverSessionsBrowserCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.sessions.browser.count metric with initial data.
func (m *metricSapnetweaverSessionsBrowserCount) init() {
	m.data.SetName("sapnetweaver.sessions.browser.count")
	m.data.SetDescription("The number of Browser Sessions.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverSessionsBrowserCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverSessionsBrowserCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverSessionsBrowserCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverSessionsBrowserCount(settings MetricSettings) metricSapnetweaverSessionsBrowserCount {
	m := metricSapnetweaverSessionsBrowserCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverSessionsEjbCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.sessions.ejb.count metric with initial data.
func (m *metricSapnetweaverSessionsEjbCount) init() {
	m.data.SetName("sapnetweaver.sessions.ejb.count")
	m.data.SetDescription("The number of EJB Sessions.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverSessionsEjbCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverSessionsEjbCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverSessionsEjbCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverSessionsEjbCount(settings MetricSettings) metricSapnetweaverSessionsEjbCount {
	m := metricSapnetweaverSessionsEjbCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverSessionsHTTPCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.sessions.http.count metric with initial data.
func (m *metricSapnetweaverSessionsHTTPCount) init() {
	m.data.SetName("sapnetweaver.sessions.http.count")
	m.data.SetDescription("The number of HTTP Sessions.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverSessionsHTTPCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverSessionsHTTPCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverSessionsHTTPCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverSessionsHTTPCount(settings MetricSettings) metricSapnetweaverSessionsHTTPCount {
	m := metricSapnetweaverSessionsHTTPCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverSessionsSecurityCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.sessions.security.count metric with initial data.
func (m *metricSapnetweaverSessionsSecurityCount) init() {
	m.data.SetName("sapnetweaver.sessions.security.count")
	m.data.SetDescription("The number of Security Sessions.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverSessionsSecurityCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverSessionsSecurityCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverSessionsSecurityCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverSessionsSecurityCount(settings MetricSettings) metricSapnetweaverSessionsSecurityCount {
	m := metricSapnetweaverSessionsSecurityCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverSessionsWebCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.sessions.web.count metric with initial data.
func (m *metricSapnetweaverSessionsWebCount) init() {
	m.data.SetName("sapnetweaver.sessions.web.count")
	m.data.SetDescription("The number of Web Sessions.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverSessionsWebCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverSessionsWebCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverSessionsWebCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverSessionsWebCount(settings MetricSettings) metricSapnetweaverSessionsWebCount {
	m := metricSapnetweaverSessionsWebCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverShortDumpsRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.short_dumps.rate metric with initial data.
func (m *metricSapnetweaverShortDumpsRate) init() {
	m.data.SetName("sapnetweaver.short_dumps.rate")
	m.data.SetDescription("The rate of Short Dumps.")
	m.data.SetUnit("{dumps/min}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverShortDumpsRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverShortDumpsRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverShortDumpsRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverShortDumpsRate(settings MetricSettings) metricSapnetweaverShortDumpsRate {
	m := metricSapnetweaverShortDumpsRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverWorkProcessesActiveCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.work_processes.active.count metric with initial data.
func (m *metricSapnetweaverWorkProcessesActiveCount) init() {
	m.data.SetName("sapnetweaver.work_processes.active.count")
	m.data.SetDescription("The number of active work processes.")
	m.data.SetUnit("{work processes}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverWorkProcessesActiveCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverWorkProcessesActiveCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverWorkProcessesActiveCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverWorkProcessesActiveCount(settings MetricSettings) metricSapnetweaverWorkProcessesActiveCount {
	m := metricSapnetweaverWorkProcessesActiveCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                                   pcommon.Timestamp   // start time that will be applied to all recorded data points.
	metricsCapacity                             int                 // maximum observed number of metrics per resource.
	resourceCapacity                            int                 // maximum observed number of resource attributes.
	metricsBuffer                               pmetric.Metrics     // accumulates metrics data before emitting.
	buildInfo                                   component.BuildInfo // contains version information
	metricSapnetweaverHostCPUUtilization        metricSapnetweaverHostCPUUtilization
	metricSapnetweaverHostMemoryVirtualOverhead metricSapnetweaverHostMemoryVirtualOverhead
	metricSapnetweaverHostMemoryVirtualSwap     metricSapnetweaverHostMemoryVirtualSwap
	metricSapnetweaverHostSpoolListUsed         metricSapnetweaverHostSpoolListUsed
	metricSapnetweaverIcmAvailability           metricSapnetweaverIcmAvailability
	metricSapnetweaverLocksEnqueueCount         metricSapnetweaverLocksEnqueueCount
	metricSapnetweaverSessionsBrowserCount      metricSapnetweaverSessionsBrowserCount
	metricSapnetweaverSessionsEjbCount          metricSapnetweaverSessionsEjbCount
	metricSapnetweaverSessionsHTTPCount         metricSapnetweaverSessionsHTTPCount
	metricSapnetweaverSessionsSecurityCount     metricSapnetweaverSessionsSecurityCount
	metricSapnetweaverSessionsWebCount          metricSapnetweaverSessionsWebCount
	metricSapnetweaverShortDumpsRate            metricSapnetweaverShortDumpsRate
	metricSapnetweaverWorkProcessesActiveCount  metricSapnetweaverWorkProcessesActiveCount
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, buildInfo component.BuildInfo, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                            pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                        pmetric.NewMetrics(),
		buildInfo:                            buildInfo,
		metricSapnetweaverHostCPUUtilization: newMetricSapnetweaverHostCPUUtilization(settings.SapnetweaverHostCPUUtilization),
		metricSapnetweaverHostMemoryVirtualOverhead: newMetricSapnetweaverHostMemoryVirtualOverhead(settings.SapnetweaverHostMemoryVirtualOverhead),
		metricSapnetweaverHostMemoryVirtualSwap:     newMetricSapnetweaverHostMemoryVirtualSwap(settings.SapnetweaverHostMemoryVirtualSwap),
		metricSapnetweaverHostSpoolListUsed:         newMetricSapnetweaverHostSpoolListUsed(settings.SapnetweaverHostSpoolListUsed),
		metricSapnetweaverIcmAvailability:           newMetricSapnetweaverIcmAvailability(settings.SapnetweaverIcmAvailability),
		metricSapnetweaverLocksEnqueueCount:         newMetricSapnetweaverLocksEnqueueCount(settings.SapnetweaverLocksEnqueueCount),
		metricSapnetweaverSessionsBrowserCount:      newMetricSapnetweaverSessionsBrowserCount(settings.SapnetweaverSessionsBrowserCount),
		metricSapnetweaverSessionsEjbCount:          newMetricSapnetweaverSessionsEjbCount(settings.SapnetweaverSessionsEjbCount),
		metricSapnetweaverSessionsHTTPCount:         newMetricSapnetweaverSessionsHTTPCount(settings.SapnetweaverSessionsHTTPCount),
		metricSapnetweaverSessionsSecurityCount:     newMetricSapnetweaverSessionsSecurityCount(settings.SapnetweaverSessionsSecurityCount),
		metricSapnetweaverSessionsWebCount:          newMetricSapnetweaverSessionsWebCount(settings.SapnetweaverSessionsWebCount),
		metricSapnetweaverShortDumpsRate:            newMetricSapnetweaverShortDumpsRate(settings.SapnetweaverShortDumpsRate),
		metricSapnetweaverWorkProcessesActiveCount:  newMetricSapnetweaverWorkProcessesActiveCount(settings.SapnetweaverWorkProcessesActiveCount),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption func(pmetric.ResourceMetrics)

// WithSapnetweaverInstance sets provided value as "sapnetweaver.instance" attribute for current resource.
func WithSapnetweaverInstance(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().PutStr("sapnetweaver.instance", val)
	}
}

// WithSapnetweaverNode sets provided value as "sapnetweaver.node" attribute for current resource.
func WithSapnetweaverNode(val string) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		rm.Resource().Attributes().PutStr("sapnetweaver.node", val)
	}
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(rmo ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/sapnetweaverreceiver")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricSapnetweaverHostCPUUtilization.emit(ils.Metrics())
	mb.metricSapnetweaverHostMemoryVirtualOverhead.emit(ils.Metrics())
	mb.metricSapnetweaverHostMemoryVirtualSwap.emit(ils.Metrics())
	mb.metricSapnetweaverHostSpoolListUsed.emit(ils.Metrics())
	mb.metricSapnetweaverIcmAvailability.emit(ils.Metrics())
	mb.metricSapnetweaverLocksEnqueueCount.emit(ils.Metrics())
	mb.metricSapnetweaverSessionsBrowserCount.emit(ils.Metrics())
	mb.metricSapnetweaverSessionsEjbCount.emit(ils.Metrics())
	mb.metricSapnetweaverSessionsHTTPCount.emit(ils.Metrics())
	mb.metricSapnetweaverSessionsSecurityCount.emit(ils.Metrics())
	mb.metricSapnetweaverSessionsWebCount.emit(ils.Metrics())
	mb.metricSapnetweaverShortDumpsRate.emit(ils.Metrics())
	mb.metricSapnetweaverWorkProcessesActiveCount.emit(ils.Metrics())
	for _, op := range rmo {
		op(rm)
	}
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(rmo ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(rmo...)
	metrics := pmetric.NewMetrics()
	mb.metricsBuffer.MoveTo(metrics)
	return metrics
}

// RecordSapnetweaverHostCPUUtilizationDataPoint adds a data point to sapnetweaver.host.cpu_utilization metric.
func (mb *MetricsBuilder) RecordSapnetweaverHostCPUUtilizationDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverHostCPUUtilization, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverHostCPUUtilization.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverHostMemoryVirtualOverheadDataPoint adds a data point to sapnetweaver.host.memory.virtual.overhead metric.
func (mb *MetricsBuilder) RecordSapnetweaverHostMemoryVirtualOverheadDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSapnetweaverHostMemoryVirtualOverhead.recordDataPoint(mb.startTime, ts, val)
}

// RecordSapnetweaverHostMemoryVirtualSwapDataPoint adds a data point to sapnetweaver.host.memory.virtual.swap metric.
func (mb *MetricsBuilder) RecordSapnetweaverHostMemoryVirtualSwapDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSapnetweaverHostMemoryVirtualSwap.recordDataPoint(mb.startTime, ts, val)
}

// RecordSapnetweaverHostSpoolListUsedDataPoint adds a data point to sapnetweaver.host.spool_list.used metric.
func (mb *MetricsBuilder) RecordSapnetweaverHostSpoolListUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverHostSpoolListUsed, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverHostSpoolListUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverIcmAvailabilityDataPoint adds a data point to sapnetweaver.icm_availability metric.
func (mb *MetricsBuilder) RecordSapnetweaverIcmAvailabilityDataPoint(ts pcommon.Timestamp, val int64, controlStateAttributeValue AttributeControlState) {
	mb.metricSapnetweaverIcmAvailability.recordDataPoint(mb.startTime, ts, val, controlStateAttributeValue.String())
}

// RecordSapnetweaverLocksEnqueueCountDataPoint adds a data point to sapnetweaver.locks.enqueue.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverLocksEnqueueCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSapnetweaverLocksEnqueueCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSapnetweaverSessionsBrowserCountDataPoint adds a data point to sapnetweaver.sessions.browser.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverSessionsBrowserCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverSessionsBrowserCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverSessionsBrowserCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverSessionsEjbCountDataPoint adds a data point to sapnetweaver.sessions.ejb.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverSessionsEjbCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverSessionsEjbCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverSessionsEjbCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverSessionsHTTPCountDataPoint adds a data point to sapnetweaver.sessions.http.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverSessionsHTTPCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverSessionsHTTPCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverSessionsHTTPCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverSessionsSecurityCountDataPoint adds a data point to sapnetweaver.sessions.security.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverSessionsSecurityCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverSessionsSecurityCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverSessionsSecurityCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverSessionsWebCountDataPoint adds a data point to sapnetweaver.sessions.web.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverSessionsWebCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverSessionsWebCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverSessionsWebCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverShortDumpsRateDataPoint adds a data point to sapnetweaver.short_dumps.rate metric.
func (mb *MetricsBuilder) RecordSapnetweaverShortDumpsRateDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverShortDumpsRate, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverShortDumpsRate.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverWorkProcessesActiveCountDataPoint adds a data point to sapnetweaver.work_processes.active.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverWorkProcessesActiveCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverWorkProcessesActiveCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverWorkProcessesActiveCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}
