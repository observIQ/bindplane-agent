// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"fmt"
	"strconv"
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/confmap"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`

	enabledSetByUser bool
}

func (ms *MetricSettings) Unmarshal(parser *confmap.Conf) error {
	if parser == nil {
		return nil
	}
	err := parser.Unmarshal(ms, confmap.WithErrorUnused())
	if err != nil {
		return err
	}
	ms.enabledSetByUser = parser.IsSet("enabled")
	return nil
}

// MetricsSettings provides settings for sapnetweaverreceiver metrics.
type MetricsSettings struct {
	SapnetweaverAbapRfcCount               MetricSettings `mapstructure:"sapnetweaver.abap.rfc.count"`
	SapnetweaverAbapSessionCount           MetricSettings `mapstructure:"sapnetweaver.abap.session.count"`
	SapnetweaverAbapUpdateStatus           MetricSettings `mapstructure:"sapnetweaver.abap.update.status"`
	SapnetweaverCacheEvictions             MetricSettings `mapstructure:"sapnetweaver.cache.evictions"`
	SapnetweaverCacheHits                  MetricSettings `mapstructure:"sapnetweaver.cache.hits"`
	SapnetweaverCertificateValidity        MetricSettings `mapstructure:"sapnetweaver.certificate.validity"`
	SapnetweaverConnectionErrorCount       MetricSettings `mapstructure:"sapnetweaver.connection.error.count"`
	SapnetweaverCPUSystemUtilization       MetricSettings `mapstructure:"sapnetweaver.cpu.system.utilization"`
	SapnetweaverCPUUtilization             MetricSettings `mapstructure:"sapnetweaver.cpu.utilization"`
	SapnetweaverDatabaseDialogRequestTime  MetricSettings `mapstructure:"sapnetweaver.database.dialog.request.time"`
	SapnetweaverHostMemoryVirtualOverhead  MetricSettings `mapstructure:"sapnetweaver.host.memory.virtual.overhead"`
	SapnetweaverHostMemoryVirtualSwap      MetricSettings `mapstructure:"sapnetweaver.host.memory.virtual.swap"`
	SapnetweaverHostSpoolListUtilization   MetricSettings `mapstructure:"sapnetweaver.host.spool_list.utilization"`
	SapnetweaverIcmErrorCount              MetricSettings `mapstructure:"sapnetweaver.icm.error.count"`
	SapnetweaverLocksDequeueErrorsCount    MetricSettings `mapstructure:"sapnetweaver.locks.dequeue.errors.count"`
	SapnetweaverLocksEnqueueCurrentCount   MetricSettings `mapstructure:"sapnetweaver.locks.enqueue.current.count"`
	SapnetweaverLocksEnqueueErrorsCount    MetricSettings `mapstructure:"sapnetweaver.locks.enqueue.errors.count"`
	SapnetweaverLocksEnqueueHighCount      MetricSettings `mapstructure:"sapnetweaver.locks.enqueue.high.count"`
	SapnetweaverLocksEnqueueLockTime       MetricSettings `mapstructure:"sapnetweaver.locks.enqueue.lock_time"`
	SapnetweaverLocksEnqueueLockWaitTime   MetricSettings `mapstructure:"sapnetweaver.locks.enqueue.lock_wait_time"`
	SapnetweaverLocksEnqueueMaxCount       MetricSettings `mapstructure:"sapnetweaver.locks.enqueue.max.count"`
	SapnetweaverMemoryConfigured           MetricSettings `mapstructure:"sapnetweaver.memory.configured"`
	SapnetweaverMemoryFree                 MetricSettings `mapstructure:"sapnetweaver.memory.free"`
	SapnetweaverMemorySwapSpaceUtilization MetricSettings `mapstructure:"sapnetweaver.memory.swap_space.utilization"`
	SapnetweaverProcessAvailability        MetricSettings `mapstructure:"sapnetweaver.process_availability"`
	SapnetweaverQueueCount                 MetricSettings `mapstructure:"sapnetweaver.queue.count"`
	SapnetweaverQueueMaxCount              MetricSettings `mapstructure:"sapnetweaver.queue_max.count"`
	SapnetweaverQueuePeakCount             MetricSettings `mapstructure:"sapnetweaver.queue_peak.count"`
	SapnetweaverRequestCount               MetricSettings `mapstructure:"sapnetweaver.request.count"`
	SapnetweaverRequestTimeoutCount        MetricSettings `mapstructure:"sapnetweaver.request.timeout.count"`
	SapnetweaverResponseDuration           MetricSettings `mapstructure:"sapnetweaver.response.duration"`
	SapnetweaverSessionCount               MetricSettings `mapstructure:"sapnetweaver.session.count"`
	SapnetweaverSessionsBrowserCount       MetricSettings `mapstructure:"sapnetweaver.sessions.browser.count"`
	SapnetweaverSessionsEjbCount           MetricSettings `mapstructure:"sapnetweaver.sessions.ejb.count"`
	SapnetweaverSessionsHTTPCount          MetricSettings `mapstructure:"sapnetweaver.sessions.http.count"`
	SapnetweaverSessionsSecurityCount      MetricSettings `mapstructure:"sapnetweaver.sessions.security.count"`
	SapnetweaverSessionsWebCount           MetricSettings `mapstructure:"sapnetweaver.sessions.web.count"`
	SapnetweaverShortDumpsRate             MetricSettings `mapstructure:"sapnetweaver.short_dumps.rate"`
	SapnetweaverSpoolRequestErrorCount     MetricSettings `mapstructure:"sapnetweaver.spool.request.error.count"`
	SapnetweaverSystemInstanceAvailability MetricSettings `mapstructure:"sapnetweaver.system.instance_availability"`
	SapnetweaverWorkProcessActiveCount     MetricSettings `mapstructure:"sapnetweaver.work_process.active.count"`
	SapnetweaverWorkProcessJobAbortedCount MetricSettings `mapstructure:"sapnetweaver.work_process.job.aborted.count"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		SapnetweaverAbapRfcCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverAbapSessionCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverAbapUpdateStatus: MetricSettings{
			Enabled: true,
		},
		SapnetweaverCacheEvictions: MetricSettings{
			Enabled: true,
		},
		SapnetweaverCacheHits: MetricSettings{
			Enabled: true,
		},
		SapnetweaverCertificateValidity: MetricSettings{
			Enabled: true,
		},
		SapnetweaverConnectionErrorCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverCPUSystemUtilization: MetricSettings{
			Enabled: true,
		},
		SapnetweaverCPUUtilization: MetricSettings{
			Enabled: true,
		},
		SapnetweaverDatabaseDialogRequestTime: MetricSettings{
			Enabled: true,
		},
		SapnetweaverHostMemoryVirtualOverhead: MetricSettings{
			Enabled: true,
		},
		SapnetweaverHostMemoryVirtualSwap: MetricSettings{
			Enabled: true,
		},
		SapnetweaverHostSpoolListUtilization: MetricSettings{
			Enabled: true,
		},
		SapnetweaverIcmErrorCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverLocksDequeueErrorsCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverLocksEnqueueCurrentCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverLocksEnqueueErrorsCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverLocksEnqueueHighCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverLocksEnqueueLockTime: MetricSettings{
			Enabled: true,
		},
		SapnetweaverLocksEnqueueLockWaitTime: MetricSettings{
			Enabled: true,
		},
		SapnetweaverLocksEnqueueMaxCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverMemoryConfigured: MetricSettings{
			Enabled: true,
		},
		SapnetweaverMemoryFree: MetricSettings{
			Enabled: true,
		},
		SapnetweaverMemorySwapSpaceUtilization: MetricSettings{
			Enabled: true,
		},
		SapnetweaverProcessAvailability: MetricSettings{
			Enabled: true,
		},
		SapnetweaverQueueCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverQueueMaxCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverQueuePeakCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverRequestCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverRequestTimeoutCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverResponseDuration: MetricSettings{
			Enabled: true,
		},
		SapnetweaverSessionCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverSessionsBrowserCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverSessionsEjbCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverSessionsHTTPCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverSessionsSecurityCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverSessionsWebCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverShortDumpsRate: MetricSettings{
			Enabled: true,
		},
		SapnetweaverSpoolRequestErrorCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverSystemInstanceAvailability: MetricSettings{
			Enabled: true,
		},
		SapnetweaverWorkProcessActiveCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverWorkProcessJobAbortedCount: MetricSettings{
			Enabled: true,
		},
	}
}

// ResourceAttributeSettings provides common settings for a particular metric.
type ResourceAttributeSettings struct {
	Enabled bool `mapstructure:"enabled"`

	enabledProvidedByUser bool
}

func (ras *ResourceAttributeSettings) Unmarshal(parser *confmap.Conf) error {
	if parser == nil {
		return nil
	}
	err := parser.Unmarshal(ras, confmap.WithErrorUnused())
	if err != nil {
		return err
	}
	ras.enabledProvidedByUser = parser.IsSet("enabled")
	return nil
}

// ResourceAttributesSettings provides settings for sapnetweaverreceiver metrics.
type ResourceAttributesSettings struct {
	SapnetweaverSID      ResourceAttributeSettings `mapstructure:"sapnetweaver.SID"`
	SapnetweaverInstance ResourceAttributeSettings `mapstructure:"sapnetweaver.instance"`
	SapnetweaverNode     ResourceAttributeSettings `mapstructure:"sapnetweaver.node"`
}

func DefaultResourceAttributesSettings() ResourceAttributesSettings {
	return ResourceAttributesSettings{
		SapnetweaverSID: ResourceAttributeSettings{
			Enabled: false,
		},
		SapnetweaverInstance: ResourceAttributeSettings{
			Enabled: false,
		},
		SapnetweaverNode: ResourceAttributeSettings{
			Enabled: false,
		},
	}
}

// AttributeControlState specifies the a value control_state attribute.
type AttributeControlState int

const (
	_ AttributeControlState = iota
	AttributeControlStateGray
	AttributeControlStateGreen
	AttributeControlStateYellow
	AttributeControlStateRed
)

// String returns the string representation of the AttributeControlState.
func (av AttributeControlState) String() string {
	switch av {
	case AttributeControlStateGray:
		return "gray"
	case AttributeControlStateGreen:
		return "green"
	case AttributeControlStateYellow:
		return "yellow"
	case AttributeControlStateRed:
		return "red"
	}
	return ""
}

// MapAttributeControlState is a helper map of string to AttributeControlState attribute value.
var MapAttributeControlState = map[string]AttributeControlState{
	"gray":   AttributeControlStateGray,
	"green":  AttributeControlStateGreen,
	"yellow": AttributeControlStateYellow,
	"red":    AttributeControlStateRed,
}

// AttributeResponseType specifies the a value response_type attribute.
type AttributeResponseType int

const (
	_ AttributeResponseType = iota
	AttributeResponseTypeTransaction
	AttributeResponseTypeDialog
	AttributeResponseTypeDialogRFC
	AttributeResponseTypeHttp
)

// String returns the string representation of the AttributeResponseType.
func (av AttributeResponseType) String() string {
	switch av {
	case AttributeResponseTypeTransaction:
		return "transaction"
	case AttributeResponseTypeDialog:
		return "dialog"
	case AttributeResponseTypeDialogRFC:
		return "dialogRFC"
	case AttributeResponseTypeHttp:
		return "http"
	}
	return ""
}

// MapAttributeResponseType is a helper map of string to AttributeResponseType attribute value.
var MapAttributeResponseType = map[string]AttributeResponseType{
	"transaction": AttributeResponseTypeTransaction,
	"dialog":      AttributeResponseTypeDialog,
	"dialogRFC":   AttributeResponseTypeDialogRFC,
	"http":        AttributeResponseTypeHttp,
}

type metricSapnetweaverAbapRfcCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.abap.rfc.count metric with initial data.
func (m *metricSapnetweaverAbapRfcCount) init() {
	m.data.SetName("sapnetweaver.abap.rfc.count")
	m.data.SetDescription("The number of ABAP RFC connections by session type.")
	m.data.SetUnit("{connections}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSapnetweaverAbapRfcCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sessionTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("session_type", sessionTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverAbapRfcCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverAbapRfcCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverAbapRfcCount(settings MetricSettings) metricSapnetweaverAbapRfcCount {
	m := metricSapnetweaverAbapRfcCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverAbapSessionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.abap.session.count metric with initial data.
func (m *metricSapnetweaverAbapSessionCount) init() {
	m.data.SetName("sapnetweaver.abap.session.count")
	m.data.SetDescription("The number of ABAP sessions by session type.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSapnetweaverAbapSessionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, sessionTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("session_type", sessionTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverAbapSessionCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverAbapSessionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverAbapSessionCount(settings MetricSettings) metricSapnetweaverAbapSessionCount {
	m := metricSapnetweaverAbapSessionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverAbapUpdateStatus struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.abap.update.status metric with initial data.
func (m *metricSapnetweaverAbapUpdateStatus) init() {
	m.data.SetName("sapnetweaver.abap.update.status")
	m.data.SetDescription("The status of the ABAP update process.")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSapnetweaverAbapUpdateStatus) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, controlStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("state", controlStateAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverAbapUpdateStatus) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverAbapUpdateStatus) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverAbapUpdateStatus(settings MetricSettings) metricSapnetweaverAbapUpdateStatus {
	m := metricSapnetweaverAbapUpdateStatus{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverCacheEvictions struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.cache.evictions metric with initial data.
func (m *metricSapnetweaverCacheEvictions) init() {
	m.data.SetName("sapnetweaver.cache.evictions")
	m.data.SetDescription("The number of evicted entries.")
	m.data.SetUnit("{entries}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverCacheEvictions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverCacheEvictions) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverCacheEvictions) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverCacheEvictions(settings MetricSettings) metricSapnetweaverCacheEvictions {
	m := metricSapnetweaverCacheEvictions{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverCacheHits struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.cache.hits metric with initial data.
func (m *metricSapnetweaverCacheHits) init() {
	m.data.SetName("sapnetweaver.cache.hits")
	m.data.SetDescription("The cache hit percentage.")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSapnetweaverCacheHits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverCacheHits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverCacheHits) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverCacheHits(settings MetricSettings) metricSapnetweaverCacheHits {
	m := metricSapnetweaverCacheHits{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverCertificateValidity struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.certificate.validity metric with initial data.
func (m *metricSapnetweaverCertificateValidity) init() {
	m.data.SetName("sapnetweaver.certificate.validity")
	m.data.SetDescription("The number of seconds until the SAP certificate expires.")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSapnetweaverCertificateValidity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, certificatePathAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("certificate_path", certificatePathAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverCertificateValidity) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverCertificateValidity) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverCertificateValidity(settings MetricSettings) metricSapnetweaverCertificateValidity {
	m := metricSapnetweaverCertificateValidity{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverConnectionErrorCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.connection.error.count metric with initial data.
func (m *metricSapnetweaverConnectionErrorCount) init() {
	m.data.SetName("sapnetweaver.connection.error.count")
	m.data.SetDescription("The amount of connection errors.")
	m.data.SetUnit("{connections}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverConnectionErrorCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverConnectionErrorCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverConnectionErrorCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverConnectionErrorCount(settings MetricSettings) metricSapnetweaverConnectionErrorCount {
	m := metricSapnetweaverConnectionErrorCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverCPUSystemUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.cpu.system.utilization metric with initial data.
func (m *metricSapnetweaverCPUSystemUtilization) init() {
	m.data.SetName("sapnetweaver.cpu.system.utilization")
	m.data.SetDescription("The system CPU utilization percentage.")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSapnetweaverCPUSystemUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverCPUSystemUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverCPUSystemUtilization) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverCPUSystemUtilization(settings MetricSettings) metricSapnetweaverCPUSystemUtilization {
	m := metricSapnetweaverCPUSystemUtilization{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverCPUUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.cpu.utilization metric with initial data.
func (m *metricSapnetweaverCPUUtilization) init() {
	m.data.SetName("sapnetweaver.cpu.utilization")
	m.data.SetDescription("The CPU utilization percentage.")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSapnetweaverCPUUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverCPUUtilization) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverCPUUtilization(settings MetricSettings) metricSapnetweaverCPUUtilization {
	m := metricSapnetweaverCPUUtilization{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverDatabaseDialogRequestTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.database.dialog.request.time metric with initial data.
func (m *metricSapnetweaverDatabaseDialogRequestTime) init() {
	m.data.SetName("sapnetweaver.database.dialog.request.time")
	m.data.SetDescription("The average time for processing logical database requests calls to the SAP database interface.")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverDatabaseDialogRequestTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverDatabaseDialogRequestTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverDatabaseDialogRequestTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverDatabaseDialogRequestTime(settings MetricSettings) metricSapnetweaverDatabaseDialogRequestTime {
	m := metricSapnetweaverDatabaseDialogRequestTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverHostMemoryVirtualOverhead struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.host.memory.virtual.overhead metric with initial data.
func (m *metricSapnetweaverHostMemoryVirtualOverhead) init() {
	m.data.SetName("sapnetweaver.host.memory.virtual.overhead")
	m.data.SetDescription("Virtualization System Memory Overhead.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricSapnetweaverHostMemoryVirtualOverhead) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverHostMemoryVirtualOverhead) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverHostMemoryVirtualOverhead) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverHostMemoryVirtualOverhead(settings MetricSettings) metricSapnetweaverHostMemoryVirtualOverhead {
	m := metricSapnetweaverHostMemoryVirtualOverhead{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverHostMemoryVirtualSwap struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.host.memory.virtual.swap metric with initial data.
func (m *metricSapnetweaverHostMemoryVirtualSwap) init() {
	m.data.SetName("sapnetweaver.host.memory.virtual.swap")
	m.data.SetDescription("Virtualization System Swap Memory.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricSapnetweaverHostMemoryVirtualSwap) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverHostMemoryVirtualSwap) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverHostMemoryVirtualSwap) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverHostMemoryVirtualSwap(settings MetricSettings) metricSapnetweaverHostMemoryVirtualSwap {
	m := metricSapnetweaverHostMemoryVirtualSwap{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverHostSpoolListUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.host.spool_list.utilization metric with initial data.
func (m *metricSapnetweaverHostSpoolListUtilization) init() {
	m.data.SetName("sapnetweaver.host.spool_list.utilization")
	m.data.SetDescription("The host spool list used percentage.")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSapnetweaverHostSpoolListUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverHostSpoolListUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverHostSpoolListUtilization) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverHostSpoolListUtilization(settings MetricSettings) metricSapnetweaverHostSpoolListUtilization {
	m := metricSapnetweaverHostSpoolListUtilization{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverIcmErrorCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.icm.error.count metric with initial data.
func (m *metricSapnetweaverIcmErrorCount) init() {
	m.data.SetName("sapnetweaver.icm.error.count")
	m.data.SetDescription("The amount of errors from */dev_icm file.")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSapnetweaverIcmErrorCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, filepathAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("filepath", filepathAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverIcmErrorCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverIcmErrorCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverIcmErrorCount(settings MetricSettings) metricSapnetweaverIcmErrorCount {
	m := metricSapnetweaverIcmErrorCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverLocksDequeueErrorsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.locks.dequeue.errors.count metric with initial data.
func (m *metricSapnetweaverLocksDequeueErrorsCount) init() {
	m.data.SetName("sapnetweaver.locks.dequeue.errors.count")
	m.data.SetDescription("The dequeued locks error count.")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverLocksDequeueErrorsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverLocksDequeueErrorsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverLocksDequeueErrorsCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverLocksDequeueErrorsCount(settings MetricSettings) metricSapnetweaverLocksDequeueErrorsCount {
	m := metricSapnetweaverLocksDequeueErrorsCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverLocksEnqueueCurrentCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.locks.enqueue.current.count metric with initial data.
func (m *metricSapnetweaverLocksEnqueueCurrentCount) init() {
	m.data.SetName("sapnetweaver.locks.enqueue.current.count")
	m.data.SetDescription("The current number of enqueued locks.")
	m.data.SetUnit("{locks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverLocksEnqueueCurrentCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverLocksEnqueueCurrentCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverLocksEnqueueCurrentCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverLocksEnqueueCurrentCount(settings MetricSettings) metricSapnetweaverLocksEnqueueCurrentCount {
	m := metricSapnetweaverLocksEnqueueCurrentCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverLocksEnqueueErrorsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.locks.enqueue.errors.count metric with initial data.
func (m *metricSapnetweaverLocksEnqueueErrorsCount) init() {
	m.data.SetName("sapnetweaver.locks.enqueue.errors.count")
	m.data.SetDescription("The enqueued locks error count.")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverLocksEnqueueErrorsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverLocksEnqueueErrorsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverLocksEnqueueErrorsCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverLocksEnqueueErrorsCount(settings MetricSettings) metricSapnetweaverLocksEnqueueErrorsCount {
	m := metricSapnetweaverLocksEnqueueErrorsCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverLocksEnqueueHighCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.locks.enqueue.high.count metric with initial data.
func (m *metricSapnetweaverLocksEnqueueHighCount) init() {
	m.data.SetName("sapnetweaver.locks.enqueue.high.count")
	m.data.SetDescription("The high number of enqueued locks.")
	m.data.SetUnit("{locks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverLocksEnqueueHighCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverLocksEnqueueHighCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverLocksEnqueueHighCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverLocksEnqueueHighCount(settings MetricSettings) metricSapnetweaverLocksEnqueueHighCount {
	m := metricSapnetweaverLocksEnqueueHighCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverLocksEnqueueLockTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.locks.enqueue.lock_time metric with initial data.
func (m *metricSapnetweaverLocksEnqueueLockTime) init() {
	m.data.SetName("sapnetweaver.locks.enqueue.lock_time")
	m.data.SetDescription("The enqueued locks time.")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverLocksEnqueueLockTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverLocksEnqueueLockTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverLocksEnqueueLockTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverLocksEnqueueLockTime(settings MetricSettings) metricSapnetweaverLocksEnqueueLockTime {
	m := metricSapnetweaverLocksEnqueueLockTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverLocksEnqueueLockWaitTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.locks.enqueue.lock_wait_time metric with initial data.
func (m *metricSapnetweaverLocksEnqueueLockWaitTime) init() {
	m.data.SetName("sapnetweaver.locks.enqueue.lock_wait_time")
	m.data.SetDescription("The enqueued locks wait time.")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverLocksEnqueueLockWaitTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverLocksEnqueueLockWaitTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverLocksEnqueueLockWaitTime) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverLocksEnqueueLockWaitTime(settings MetricSettings) metricSapnetweaverLocksEnqueueLockWaitTime {
	m := metricSapnetweaverLocksEnqueueLockWaitTime{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverLocksEnqueueMaxCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.locks.enqueue.max.count metric with initial data.
func (m *metricSapnetweaverLocksEnqueueMaxCount) init() {
	m.data.SetName("sapnetweaver.locks.enqueue.max.count")
	m.data.SetDescription("The max number of enqueued locks.")
	m.data.SetUnit("{locks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverLocksEnqueueMaxCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverLocksEnqueueMaxCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverLocksEnqueueMaxCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverLocksEnqueueMaxCount(settings MetricSettings) metricSapnetweaverLocksEnqueueMaxCount {
	m := metricSapnetweaverLocksEnqueueMaxCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverMemoryConfigured struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.memory.configured metric with initial data.
func (m *metricSapnetweaverMemoryConfigured) init() {
	m.data.SetName("sapnetweaver.memory.configured")
	m.data.SetDescription("The amount of configured memory.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverMemoryConfigured) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverMemoryConfigured) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverMemoryConfigured) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverMemoryConfigured(settings MetricSettings) metricSapnetweaverMemoryConfigured {
	m := metricSapnetweaverMemoryConfigured{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverMemoryFree struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.memory.free metric with initial data.
func (m *metricSapnetweaverMemoryFree) init() {
	m.data.SetName("sapnetweaver.memory.free")
	m.data.SetDescription("The amount of free memory.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverMemoryFree) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverMemoryFree) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverMemoryFree) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverMemoryFree(settings MetricSettings) metricSapnetweaverMemoryFree {
	m := metricSapnetweaverMemoryFree{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverMemorySwapSpaceUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.memory.swap_space.utilization metric with initial data.
func (m *metricSapnetweaverMemorySwapSpaceUtilization) init() {
	m.data.SetName("sapnetweaver.memory.swap_space.utilization")
	m.data.SetDescription("The swap space utilization percentage.")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSapnetweaverMemorySwapSpaceUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverMemorySwapSpaceUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverMemorySwapSpaceUtilization) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverMemorySwapSpaceUtilization(settings MetricSettings) metricSapnetweaverMemorySwapSpaceUtilization {
	m := metricSapnetweaverMemorySwapSpaceUtilization{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverProcessAvailability struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.process_availability metric with initial data.
func (m *metricSapnetweaverProcessAvailability) init() {
	m.data.SetName("sapnetweaver.process_availability")
	m.data.SetDescription("The processes availability directly started by the sapstartsrv Web service.")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSapnetweaverProcessAvailability) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, processNameAttributeValue string, processDescriptionAttributeValue string, controlStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("process_name", processNameAttributeValue)
	dp.Attributes().PutStr("process_description", processDescriptionAttributeValue)
	dp.Attributes().PutStr("state", controlStateAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverProcessAvailability) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverProcessAvailability) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverProcessAvailability(settings MetricSettings) metricSapnetweaverProcessAvailability {
	m := metricSapnetweaverProcessAvailability{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverQueueCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.queue.count metric with initial data.
func (m *metricSapnetweaverQueueCount) init() {
	m.data.SetName("sapnetweaver.queue.count")
	m.data.SetDescription("The queue length.")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSapnetweaverQueueCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, wpTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("wp_type", wpTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverQueueCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverQueueCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverQueueCount(settings MetricSettings) metricSapnetweaverQueueCount {
	m := metricSapnetweaverQueueCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverQueueMaxCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.queue_max.count metric with initial data.
func (m *metricSapnetweaverQueueMaxCount) init() {
	m.data.SetName("sapnetweaver.queue_max.count")
	m.data.SetDescription("The max queue length.")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSapnetweaverQueueMaxCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, wpTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("wp_type", wpTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverQueueMaxCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverQueueMaxCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverQueueMaxCount(settings MetricSettings) metricSapnetweaverQueueMaxCount {
	m := metricSapnetweaverQueueMaxCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverQueuePeakCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.queue_peak.count metric with initial data.
func (m *metricSapnetweaverQueuePeakCount) init() {
	m.data.SetName("sapnetweaver.queue_peak.count")
	m.data.SetDescription("The peak queue length.")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSapnetweaverQueuePeakCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, wpTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("wp_type", wpTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverQueuePeakCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverQueuePeakCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverQueuePeakCount(settings MetricSettings) metricSapnetweaverQueuePeakCount {
	m := metricSapnetweaverQueuePeakCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverRequestCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.request.count metric with initial data.
func (m *metricSapnetweaverRequestCount) init() {
	m.data.SetName("sapnetweaver.request.count")
	m.data.SetDescription("The amount of requests made.")
	m.data.SetUnit("{requests}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverRequestCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverRequestCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverRequestCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverRequestCount(settings MetricSettings) metricSapnetweaverRequestCount {
	m := metricSapnetweaverRequestCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverRequestTimeoutCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.request.timeout.count metric with initial data.
func (m *metricSapnetweaverRequestTimeoutCount) init() {
	m.data.SetName("sapnetweaver.request.timeout.count")
	m.data.SetDescription("The amount of timed out requests.")
	m.data.SetUnit("{timeouts}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverRequestTimeoutCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverRequestTimeoutCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverRequestTimeoutCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverRequestTimeoutCount(settings MetricSettings) metricSapnetweaverRequestTimeoutCount {
	m := metricSapnetweaverRequestTimeoutCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverResponseDuration struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.response.duration metric with initial data.
func (m *metricSapnetweaverResponseDuration) init() {
	m.data.SetName("sapnetweaver.response.duration")
	m.data.SetDescription("The response time duration.")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSapnetweaverResponseDuration) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, responseTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("response_type", responseTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverResponseDuration) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverResponseDuration) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverResponseDuration(settings MetricSettings) metricSapnetweaverResponseDuration {
	m := metricSapnetweaverResponseDuration{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverSessionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.session.count metric with initial data.
func (m *metricSapnetweaverSessionCount) init() {
	m.data.SetName("sapnetweaver.session.count")
	m.data.SetDescription("The amount of of sessions created.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverSessionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverSessionCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverSessionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverSessionCount(settings MetricSettings) metricSapnetweaverSessionCount {
	m := metricSapnetweaverSessionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverSessionsBrowserCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.sessions.browser.count metric with initial data.
func (m *metricSapnetweaverSessionsBrowserCount) init() {
	m.data.SetName("sapnetweaver.sessions.browser.count")
	m.data.SetDescription("The number of Browser Sessions.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverSessionsBrowserCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverSessionsBrowserCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverSessionsBrowserCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverSessionsBrowserCount(settings MetricSettings) metricSapnetweaverSessionsBrowserCount {
	m := metricSapnetweaverSessionsBrowserCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverSessionsEjbCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.sessions.ejb.count metric with initial data.
func (m *metricSapnetweaverSessionsEjbCount) init() {
	m.data.SetName("sapnetweaver.sessions.ejb.count")
	m.data.SetDescription("The number of EJB Sessions.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverSessionsEjbCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverSessionsEjbCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverSessionsEjbCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverSessionsEjbCount(settings MetricSettings) metricSapnetweaverSessionsEjbCount {
	m := metricSapnetweaverSessionsEjbCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverSessionsHTTPCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.sessions.http.count metric with initial data.
func (m *metricSapnetweaverSessionsHTTPCount) init() {
	m.data.SetName("sapnetweaver.sessions.http.count")
	m.data.SetDescription("The number of HTTP Sessions.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverSessionsHTTPCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverSessionsHTTPCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverSessionsHTTPCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverSessionsHTTPCount(settings MetricSettings) metricSapnetweaverSessionsHTTPCount {
	m := metricSapnetweaverSessionsHTTPCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverSessionsSecurityCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.sessions.security.count metric with initial data.
func (m *metricSapnetweaverSessionsSecurityCount) init() {
	m.data.SetName("sapnetweaver.sessions.security.count")
	m.data.SetDescription("The number of Security Sessions.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverSessionsSecurityCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverSessionsSecurityCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverSessionsSecurityCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverSessionsSecurityCount(settings MetricSettings) metricSapnetweaverSessionsSecurityCount {
	m := metricSapnetweaverSessionsSecurityCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverSessionsWebCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.sessions.web.count metric with initial data.
func (m *metricSapnetweaverSessionsWebCount) init() {
	m.data.SetName("sapnetweaver.sessions.web.count")
	m.data.SetDescription("The number of Web Sessions.")
	m.data.SetUnit("{sessions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverSessionsWebCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverSessionsWebCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverSessionsWebCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverSessionsWebCount(settings MetricSettings) metricSapnetweaverSessionsWebCount {
	m := metricSapnetweaverSessionsWebCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverShortDumpsRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.short_dumps.rate metric with initial data.
func (m *metricSapnetweaverShortDumpsRate) init() {
	m.data.SetName("sapnetweaver.short_dumps.rate")
	m.data.SetDescription("The rate of Short Dumps.")
	m.data.SetUnit("{dumps}/min")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverShortDumpsRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverShortDumpsRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverShortDumpsRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverShortDumpsRate(settings MetricSettings) metricSapnetweaverShortDumpsRate {
	m := metricSapnetweaverShortDumpsRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverSpoolRequestErrorCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.spool.request.error.count metric with initial data.
func (m *metricSapnetweaverSpoolRequestErrorCount) init() {
	m.data.SetName("sapnetweaver.spool.request.error.count")
	m.data.SetDescription("The number of spool work processes that have encountered errors.")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverSpoolRequestErrorCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverSpoolRequestErrorCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverSpoolRequestErrorCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverSpoolRequestErrorCount(settings MetricSettings) metricSapnetweaverSpoolRequestErrorCount {
	m := metricSapnetweaverSpoolRequestErrorCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverSystemInstanceAvailability struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.system.instance_availability metric with initial data.
func (m *metricSapnetweaverSystemInstanceAvailability) init() {
	m.data.SetName("sapnetweaver.system.instance_availability")
	m.data.SetDescription("The availability status of each system instance.")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSapnetweaverSystemInstanceAvailability) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, instanceNumberAttributeValue int64, featureAttributeValue string, controlStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutInt("instance_number", instanceNumberAttributeValue)
	dp.Attributes().PutStr("feature", featureAttributeValue)
	dp.Attributes().PutStr("state", controlStateAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverSystemInstanceAvailability) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverSystemInstanceAvailability) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverSystemInstanceAvailability(settings MetricSettings) metricSapnetweaverSystemInstanceAvailability {
	m := metricSapnetweaverSystemInstanceAvailability{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverWorkProcessActiveCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.work_process.active.count metric with initial data.
func (m *metricSapnetweaverWorkProcessActiveCount) init() {
	m.data.SetName("sapnetweaver.work_process.active.count")
	m.data.SetDescription("The number of free ABAP work processes in the system.")
	m.data.SetUnit("{work_processes}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSapnetweaverWorkProcessActiveCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, instanceAttributeValue string, wpTypeAttributeValue string, wpStatusAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("instance", instanceAttributeValue)
	dp.Attributes().PutStr("wp_type", wpTypeAttributeValue)
	dp.Attributes().PutStr("wp_status", wpStatusAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverWorkProcessActiveCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverWorkProcessActiveCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverWorkProcessActiveCount(settings MetricSettings) metricSapnetweaverWorkProcessActiveCount {
	m := metricSapnetweaverWorkProcessActiveCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverWorkProcessJobAbortedCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.work_process.job.aborted.count metric with initial data.
func (m *metricSapnetweaverWorkProcessJobAbortedCount) init() {
	m.data.SetName("sapnetweaver.work_process.job.aborted.count")
	m.data.SetDescription("The individual aborted jobs on an application server.")
	m.data.SetUnit("{aborted_jobs}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverWorkProcessJobAbortedCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverWorkProcessJobAbortedCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverWorkProcessJobAbortedCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverWorkProcessJobAbortedCount(settings MetricSettings) metricSapnetweaverWorkProcessJobAbortedCount {
	m := metricSapnetweaverWorkProcessJobAbortedCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                                    pcommon.Timestamp   // start time that will be applied to all recorded data points.
	metricsCapacity                              int                 // maximum observed number of metrics per resource.
	resourceCapacity                             int                 // maximum observed number of resource attributes.
	metricsBuffer                                pmetric.Metrics     // accumulates metrics data before emitting.
	buildInfo                                    component.BuildInfo // contains version information
	resourceAttributesSettings                   ResourceAttributesSettings
	metricSapnetweaverAbapRfcCount               metricSapnetweaverAbapRfcCount
	metricSapnetweaverAbapSessionCount           metricSapnetweaverAbapSessionCount
	metricSapnetweaverAbapUpdateStatus           metricSapnetweaverAbapUpdateStatus
	metricSapnetweaverCacheEvictions             metricSapnetweaverCacheEvictions
	metricSapnetweaverCacheHits                  metricSapnetweaverCacheHits
	metricSapnetweaverCertificateValidity        metricSapnetweaverCertificateValidity
	metricSapnetweaverConnectionErrorCount       metricSapnetweaverConnectionErrorCount
	metricSapnetweaverCPUSystemUtilization       metricSapnetweaverCPUSystemUtilization
	metricSapnetweaverCPUUtilization             metricSapnetweaverCPUUtilization
	metricSapnetweaverDatabaseDialogRequestTime  metricSapnetweaverDatabaseDialogRequestTime
	metricSapnetweaverHostMemoryVirtualOverhead  metricSapnetweaverHostMemoryVirtualOverhead
	metricSapnetweaverHostMemoryVirtualSwap      metricSapnetweaverHostMemoryVirtualSwap
	metricSapnetweaverHostSpoolListUtilization   metricSapnetweaverHostSpoolListUtilization
	metricSapnetweaverIcmErrorCount              metricSapnetweaverIcmErrorCount
	metricSapnetweaverLocksDequeueErrorsCount    metricSapnetweaverLocksDequeueErrorsCount
	metricSapnetweaverLocksEnqueueCurrentCount   metricSapnetweaverLocksEnqueueCurrentCount
	metricSapnetweaverLocksEnqueueErrorsCount    metricSapnetweaverLocksEnqueueErrorsCount
	metricSapnetweaverLocksEnqueueHighCount      metricSapnetweaverLocksEnqueueHighCount
	metricSapnetweaverLocksEnqueueLockTime       metricSapnetweaverLocksEnqueueLockTime
	metricSapnetweaverLocksEnqueueLockWaitTime   metricSapnetweaverLocksEnqueueLockWaitTime
	metricSapnetweaverLocksEnqueueMaxCount       metricSapnetweaverLocksEnqueueMaxCount
	metricSapnetweaverMemoryConfigured           metricSapnetweaverMemoryConfigured
	metricSapnetweaverMemoryFree                 metricSapnetweaverMemoryFree
	metricSapnetweaverMemorySwapSpaceUtilization metricSapnetweaverMemorySwapSpaceUtilization
	metricSapnetweaverProcessAvailability        metricSapnetweaverProcessAvailability
	metricSapnetweaverQueueCount                 metricSapnetweaverQueueCount
	metricSapnetweaverQueueMaxCount              metricSapnetweaverQueueMaxCount
	metricSapnetweaverQueuePeakCount             metricSapnetweaverQueuePeakCount
	metricSapnetweaverRequestCount               metricSapnetweaverRequestCount
	metricSapnetweaverRequestTimeoutCount        metricSapnetweaverRequestTimeoutCount
	metricSapnetweaverResponseDuration           metricSapnetweaverResponseDuration
	metricSapnetweaverSessionCount               metricSapnetweaverSessionCount
	metricSapnetweaverSessionsBrowserCount       metricSapnetweaverSessionsBrowserCount
	metricSapnetweaverSessionsEjbCount           metricSapnetweaverSessionsEjbCount
	metricSapnetweaverSessionsHTTPCount          metricSapnetweaverSessionsHTTPCount
	metricSapnetweaverSessionsSecurityCount      metricSapnetweaverSessionsSecurityCount
	metricSapnetweaverSessionsWebCount           metricSapnetweaverSessionsWebCount
	metricSapnetweaverShortDumpsRate             metricSapnetweaverShortDumpsRate
	metricSapnetweaverSpoolRequestErrorCount     metricSapnetweaverSpoolRequestErrorCount
	metricSapnetweaverSystemInstanceAvailability metricSapnetweaverSystemInstanceAvailability
	metricSapnetweaverWorkProcessActiveCount     metricSapnetweaverWorkProcessActiveCount
	metricSapnetweaverWorkProcessJobAbortedCount metricSapnetweaverWorkProcessJobAbortedCount
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

// WithResourceAttributesSettings sets ResourceAttributeSettings on the metrics builder.
func WithResourceAttributesSettings(ras ResourceAttributesSettings) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.resourceAttributesSettings = ras
	}
}

func NewMetricsBuilder(ms MetricsSettings, settings receiver.CreateSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                                    pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                                pmetric.NewMetrics(),
		buildInfo:                                    settings.BuildInfo,
		resourceAttributesSettings:                   DefaultResourceAttributesSettings(),
		metricSapnetweaverAbapRfcCount:               newMetricSapnetweaverAbapRfcCount(ms.SapnetweaverAbapRfcCount),
		metricSapnetweaverAbapSessionCount:           newMetricSapnetweaverAbapSessionCount(ms.SapnetweaverAbapSessionCount),
		metricSapnetweaverAbapUpdateStatus:           newMetricSapnetweaverAbapUpdateStatus(ms.SapnetweaverAbapUpdateStatus),
		metricSapnetweaverCacheEvictions:             newMetricSapnetweaverCacheEvictions(ms.SapnetweaverCacheEvictions),
		metricSapnetweaverCacheHits:                  newMetricSapnetweaverCacheHits(ms.SapnetweaverCacheHits),
		metricSapnetweaverCertificateValidity:        newMetricSapnetweaverCertificateValidity(ms.SapnetweaverCertificateValidity),
		metricSapnetweaverConnectionErrorCount:       newMetricSapnetweaverConnectionErrorCount(ms.SapnetweaverConnectionErrorCount),
		metricSapnetweaverCPUSystemUtilization:       newMetricSapnetweaverCPUSystemUtilization(ms.SapnetweaverCPUSystemUtilization),
		metricSapnetweaverCPUUtilization:             newMetricSapnetweaverCPUUtilization(ms.SapnetweaverCPUUtilization),
		metricSapnetweaverDatabaseDialogRequestTime:  newMetricSapnetweaverDatabaseDialogRequestTime(ms.SapnetweaverDatabaseDialogRequestTime),
		metricSapnetweaverHostMemoryVirtualOverhead:  newMetricSapnetweaverHostMemoryVirtualOverhead(ms.SapnetweaverHostMemoryVirtualOverhead),
		metricSapnetweaverHostMemoryVirtualSwap:      newMetricSapnetweaverHostMemoryVirtualSwap(ms.SapnetweaverHostMemoryVirtualSwap),
		metricSapnetweaverHostSpoolListUtilization:   newMetricSapnetweaverHostSpoolListUtilization(ms.SapnetweaverHostSpoolListUtilization),
		metricSapnetweaverIcmErrorCount:              newMetricSapnetweaverIcmErrorCount(ms.SapnetweaverIcmErrorCount),
		metricSapnetweaverLocksDequeueErrorsCount:    newMetricSapnetweaverLocksDequeueErrorsCount(ms.SapnetweaverLocksDequeueErrorsCount),
		metricSapnetweaverLocksEnqueueCurrentCount:   newMetricSapnetweaverLocksEnqueueCurrentCount(ms.SapnetweaverLocksEnqueueCurrentCount),
		metricSapnetweaverLocksEnqueueErrorsCount:    newMetricSapnetweaverLocksEnqueueErrorsCount(ms.SapnetweaverLocksEnqueueErrorsCount),
		metricSapnetweaverLocksEnqueueHighCount:      newMetricSapnetweaverLocksEnqueueHighCount(ms.SapnetweaverLocksEnqueueHighCount),
		metricSapnetweaverLocksEnqueueLockTime:       newMetricSapnetweaverLocksEnqueueLockTime(ms.SapnetweaverLocksEnqueueLockTime),
		metricSapnetweaverLocksEnqueueLockWaitTime:   newMetricSapnetweaverLocksEnqueueLockWaitTime(ms.SapnetweaverLocksEnqueueLockWaitTime),
		metricSapnetweaverLocksEnqueueMaxCount:       newMetricSapnetweaverLocksEnqueueMaxCount(ms.SapnetweaverLocksEnqueueMaxCount),
		metricSapnetweaverMemoryConfigured:           newMetricSapnetweaverMemoryConfigured(ms.SapnetweaverMemoryConfigured),
		metricSapnetweaverMemoryFree:                 newMetricSapnetweaverMemoryFree(ms.SapnetweaverMemoryFree),
		metricSapnetweaverMemorySwapSpaceUtilization: newMetricSapnetweaverMemorySwapSpaceUtilization(ms.SapnetweaverMemorySwapSpaceUtilization),
		metricSapnetweaverProcessAvailability:        newMetricSapnetweaverProcessAvailability(ms.SapnetweaverProcessAvailability),
		metricSapnetweaverQueueCount:                 newMetricSapnetweaverQueueCount(ms.SapnetweaverQueueCount),
		metricSapnetweaverQueueMaxCount:              newMetricSapnetweaverQueueMaxCount(ms.SapnetweaverQueueMaxCount),
		metricSapnetweaverQueuePeakCount:             newMetricSapnetweaverQueuePeakCount(ms.SapnetweaverQueuePeakCount),
		metricSapnetweaverRequestCount:               newMetricSapnetweaverRequestCount(ms.SapnetweaverRequestCount),
		metricSapnetweaverRequestTimeoutCount:        newMetricSapnetweaverRequestTimeoutCount(ms.SapnetweaverRequestTimeoutCount),
		metricSapnetweaverResponseDuration:           newMetricSapnetweaverResponseDuration(ms.SapnetweaverResponseDuration),
		metricSapnetweaverSessionCount:               newMetricSapnetweaverSessionCount(ms.SapnetweaverSessionCount),
		metricSapnetweaverSessionsBrowserCount:       newMetricSapnetweaverSessionsBrowserCount(ms.SapnetweaverSessionsBrowserCount),
		metricSapnetweaverSessionsEjbCount:           newMetricSapnetweaverSessionsEjbCount(ms.SapnetweaverSessionsEjbCount),
		metricSapnetweaverSessionsHTTPCount:          newMetricSapnetweaverSessionsHTTPCount(ms.SapnetweaverSessionsHTTPCount),
		metricSapnetweaverSessionsSecurityCount:      newMetricSapnetweaverSessionsSecurityCount(ms.SapnetweaverSessionsSecurityCount),
		metricSapnetweaverSessionsWebCount:           newMetricSapnetweaverSessionsWebCount(ms.SapnetweaverSessionsWebCount),
		metricSapnetweaverShortDumpsRate:             newMetricSapnetweaverShortDumpsRate(ms.SapnetweaverShortDumpsRate),
		metricSapnetweaverSpoolRequestErrorCount:     newMetricSapnetweaverSpoolRequestErrorCount(ms.SapnetweaverSpoolRequestErrorCount),
		metricSapnetweaverSystemInstanceAvailability: newMetricSapnetweaverSystemInstanceAvailability(ms.SapnetweaverSystemInstanceAvailability),
		metricSapnetweaverWorkProcessActiveCount:     newMetricSapnetweaverWorkProcessActiveCount(ms.SapnetweaverWorkProcessActiveCount),
		metricSapnetweaverWorkProcessJobAbortedCount: newMetricSapnetweaverWorkProcessJobAbortedCount(ms.SapnetweaverWorkProcessJobAbortedCount),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption func(ResourceAttributesSettings, pmetric.ResourceMetrics)

// WithSapnetweaverSID sets provided value as "sapnetweaver.SID" attribute for current resource.
func WithSapnetweaverSID(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.SapnetweaverSID.Enabled {
			rm.Resource().Attributes().PutStr("sapnetweaver.SID", val)
		}
	}
}

// WithSapnetweaverInstance sets provided value as "sapnetweaver.instance" attribute for current resource.
func WithSapnetweaverInstance(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.SapnetweaverInstance.Enabled {
			rm.Resource().Attributes().PutStr("sapnetweaver.instance", val)
		}
	}
}

// WithSapnetweaverNode sets provided value as "sapnetweaver.node" attribute for current resource.
func WithSapnetweaverNode(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.SapnetweaverNode.Enabled {
			rm.Resource().Attributes().PutStr("sapnetweaver.node", val)
		}
	}
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(rmo ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/sapnetweaverreceiver")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricSapnetweaverAbapRfcCount.emit(ils.Metrics())
	mb.metricSapnetweaverAbapSessionCount.emit(ils.Metrics())
	mb.metricSapnetweaverAbapUpdateStatus.emit(ils.Metrics())
	mb.metricSapnetweaverCacheEvictions.emit(ils.Metrics())
	mb.metricSapnetweaverCacheHits.emit(ils.Metrics())
	mb.metricSapnetweaverCertificateValidity.emit(ils.Metrics())
	mb.metricSapnetweaverConnectionErrorCount.emit(ils.Metrics())
	mb.metricSapnetweaverCPUSystemUtilization.emit(ils.Metrics())
	mb.metricSapnetweaverCPUUtilization.emit(ils.Metrics())
	mb.metricSapnetweaverDatabaseDialogRequestTime.emit(ils.Metrics())
	mb.metricSapnetweaverHostMemoryVirtualOverhead.emit(ils.Metrics())
	mb.metricSapnetweaverHostMemoryVirtualSwap.emit(ils.Metrics())
	mb.metricSapnetweaverHostSpoolListUtilization.emit(ils.Metrics())
	mb.metricSapnetweaverIcmErrorCount.emit(ils.Metrics())
	mb.metricSapnetweaverLocksDequeueErrorsCount.emit(ils.Metrics())
	mb.metricSapnetweaverLocksEnqueueCurrentCount.emit(ils.Metrics())
	mb.metricSapnetweaverLocksEnqueueErrorsCount.emit(ils.Metrics())
	mb.metricSapnetweaverLocksEnqueueHighCount.emit(ils.Metrics())
	mb.metricSapnetweaverLocksEnqueueLockTime.emit(ils.Metrics())
	mb.metricSapnetweaverLocksEnqueueLockWaitTime.emit(ils.Metrics())
	mb.metricSapnetweaverLocksEnqueueMaxCount.emit(ils.Metrics())
	mb.metricSapnetweaverMemoryConfigured.emit(ils.Metrics())
	mb.metricSapnetweaverMemoryFree.emit(ils.Metrics())
	mb.metricSapnetweaverMemorySwapSpaceUtilization.emit(ils.Metrics())
	mb.metricSapnetweaverProcessAvailability.emit(ils.Metrics())
	mb.metricSapnetweaverQueueCount.emit(ils.Metrics())
	mb.metricSapnetweaverQueueMaxCount.emit(ils.Metrics())
	mb.metricSapnetweaverQueuePeakCount.emit(ils.Metrics())
	mb.metricSapnetweaverRequestCount.emit(ils.Metrics())
	mb.metricSapnetweaverRequestTimeoutCount.emit(ils.Metrics())
	mb.metricSapnetweaverResponseDuration.emit(ils.Metrics())
	mb.metricSapnetweaverSessionCount.emit(ils.Metrics())
	mb.metricSapnetweaverSessionsBrowserCount.emit(ils.Metrics())
	mb.metricSapnetweaverSessionsEjbCount.emit(ils.Metrics())
	mb.metricSapnetweaverSessionsHTTPCount.emit(ils.Metrics())
	mb.metricSapnetweaverSessionsSecurityCount.emit(ils.Metrics())
	mb.metricSapnetweaverSessionsWebCount.emit(ils.Metrics())
	mb.metricSapnetweaverShortDumpsRate.emit(ils.Metrics())
	mb.metricSapnetweaverSpoolRequestErrorCount.emit(ils.Metrics())
	mb.metricSapnetweaverSystemInstanceAvailability.emit(ils.Metrics())
	mb.metricSapnetweaverWorkProcessActiveCount.emit(ils.Metrics())
	mb.metricSapnetweaverWorkProcessJobAbortedCount.emit(ils.Metrics())

	for _, op := range rmo {
		op(mb.resourceAttributesSettings, rm)
	}
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(rmo ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(rmo...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordSapnetweaverAbapRfcCountDataPoint adds a data point to sapnetweaver.abap.rfc.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverAbapRfcCountDataPoint(ts pcommon.Timestamp, val int64, sessionTypeAttributeValue string) {
	mb.metricSapnetweaverAbapRfcCount.recordDataPoint(mb.startTime, ts, val, sessionTypeAttributeValue)
}

// RecordSapnetweaverAbapSessionCountDataPoint adds a data point to sapnetweaver.abap.session.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverAbapSessionCountDataPoint(ts pcommon.Timestamp, val int64, sessionTypeAttributeValue string) {
	mb.metricSapnetweaverAbapSessionCount.recordDataPoint(mb.startTime, ts, val, sessionTypeAttributeValue)
}

// RecordSapnetweaverAbapUpdateStatusDataPoint adds a data point to sapnetweaver.abap.update.status metric.
func (mb *MetricsBuilder) RecordSapnetweaverAbapUpdateStatusDataPoint(ts pcommon.Timestamp, val int64, controlStateAttributeValue AttributeControlState) {
	mb.metricSapnetweaverAbapUpdateStatus.recordDataPoint(mb.startTime, ts, val, controlStateAttributeValue.String())
}

// RecordSapnetweaverCacheEvictionsDataPoint adds a data point to sapnetweaver.cache.evictions metric.
func (mb *MetricsBuilder) RecordSapnetweaverCacheEvictionsDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverCacheEvictions, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverCacheEvictions.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverCacheHitsDataPoint adds a data point to sapnetweaver.cache.hits metric.
func (mb *MetricsBuilder) RecordSapnetweaverCacheHitsDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverCacheHits, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverCacheHits.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverCertificateValidityDataPoint adds a data point to sapnetweaver.certificate.validity metric.
func (mb *MetricsBuilder) RecordSapnetweaverCertificateValidityDataPoint(ts pcommon.Timestamp, val int64, certificatePathAttributeValue string) {
	mb.metricSapnetweaverCertificateValidity.recordDataPoint(mb.startTime, ts, val, certificatePathAttributeValue)
}

// RecordSapnetweaverConnectionErrorCountDataPoint adds a data point to sapnetweaver.connection.error.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverConnectionErrorCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverConnectionErrorCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverConnectionErrorCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverCPUSystemUtilizationDataPoint adds a data point to sapnetweaver.cpu.system.utilization metric.
func (mb *MetricsBuilder) RecordSapnetweaverCPUSystemUtilizationDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverCPUSystemUtilization, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverCPUSystemUtilization.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverCPUUtilizationDataPoint adds a data point to sapnetweaver.cpu.utilization metric.
func (mb *MetricsBuilder) RecordSapnetweaverCPUUtilizationDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverCPUUtilization, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverCPUUtilization.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverDatabaseDialogRequestTimeDataPoint adds a data point to sapnetweaver.database.dialog.request.time metric.
func (mb *MetricsBuilder) RecordSapnetweaverDatabaseDialogRequestTimeDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverDatabaseDialogRequestTime, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverDatabaseDialogRequestTime.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverHostMemoryVirtualOverheadDataPoint adds a data point to sapnetweaver.host.memory.virtual.overhead metric.
func (mb *MetricsBuilder) RecordSapnetweaverHostMemoryVirtualOverheadDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSapnetweaverHostMemoryVirtualOverhead.recordDataPoint(mb.startTime, ts, val)
}

// RecordSapnetweaverHostMemoryVirtualSwapDataPoint adds a data point to sapnetweaver.host.memory.virtual.swap metric.
func (mb *MetricsBuilder) RecordSapnetweaverHostMemoryVirtualSwapDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSapnetweaverHostMemoryVirtualSwap.recordDataPoint(mb.startTime, ts, val)
}

// RecordSapnetweaverHostSpoolListUtilizationDataPoint adds a data point to sapnetweaver.host.spool_list.utilization metric.
func (mb *MetricsBuilder) RecordSapnetweaverHostSpoolListUtilizationDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverHostSpoolListUtilization, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverHostSpoolListUtilization.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverIcmErrorCountDataPoint adds a data point to sapnetweaver.icm.error.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverIcmErrorCountDataPoint(ts pcommon.Timestamp, val int64, filepathAttributeValue string) {
	mb.metricSapnetweaverIcmErrorCount.recordDataPoint(mb.startTime, ts, val, filepathAttributeValue)
}

// RecordSapnetweaverLocksDequeueErrorsCountDataPoint adds a data point to sapnetweaver.locks.dequeue.errors.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverLocksDequeueErrorsCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSapnetweaverLocksDequeueErrorsCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSapnetweaverLocksEnqueueCurrentCountDataPoint adds a data point to sapnetweaver.locks.enqueue.current.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverLocksEnqueueCurrentCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSapnetweaverLocksEnqueueCurrentCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSapnetweaverLocksEnqueueErrorsCountDataPoint adds a data point to sapnetweaver.locks.enqueue.errors.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverLocksEnqueueErrorsCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSapnetweaverLocksEnqueueErrorsCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSapnetweaverLocksEnqueueHighCountDataPoint adds a data point to sapnetweaver.locks.enqueue.high.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverLocksEnqueueHighCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSapnetweaverLocksEnqueueHighCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSapnetweaverLocksEnqueueLockTimeDataPoint adds a data point to sapnetweaver.locks.enqueue.lock_time metric.
func (mb *MetricsBuilder) RecordSapnetweaverLocksEnqueueLockTimeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSapnetweaverLocksEnqueueLockTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordSapnetweaverLocksEnqueueLockWaitTimeDataPoint adds a data point to sapnetweaver.locks.enqueue.lock_wait_time metric.
func (mb *MetricsBuilder) RecordSapnetweaverLocksEnqueueLockWaitTimeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSapnetweaverLocksEnqueueLockWaitTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordSapnetweaverLocksEnqueueMaxCountDataPoint adds a data point to sapnetweaver.locks.enqueue.max.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverLocksEnqueueMaxCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSapnetweaverLocksEnqueueMaxCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordSapnetweaverMemoryConfiguredDataPoint adds a data point to sapnetweaver.memory.configured metric.
func (mb *MetricsBuilder) RecordSapnetweaverMemoryConfiguredDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSapnetweaverMemoryConfigured.recordDataPoint(mb.startTime, ts, val)
}

// RecordSapnetweaverMemoryFreeDataPoint adds a data point to sapnetweaver.memory.free metric.
func (mb *MetricsBuilder) RecordSapnetweaverMemoryFreeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSapnetweaverMemoryFree.recordDataPoint(mb.startTime, ts, val)
}

// RecordSapnetweaverMemorySwapSpaceUtilizationDataPoint adds a data point to sapnetweaver.memory.swap_space.utilization metric.
func (mb *MetricsBuilder) RecordSapnetweaverMemorySwapSpaceUtilizationDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverMemorySwapSpaceUtilization, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverMemorySwapSpaceUtilization.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverProcessAvailabilityDataPoint adds a data point to sapnetweaver.process_availability metric.
func (mb *MetricsBuilder) RecordSapnetweaverProcessAvailabilityDataPoint(ts pcommon.Timestamp, val int64, processNameAttributeValue string, processDescriptionAttributeValue string, controlStateAttributeValue AttributeControlState) {
	mb.metricSapnetweaverProcessAvailability.recordDataPoint(mb.startTime, ts, val, processNameAttributeValue, processDescriptionAttributeValue, controlStateAttributeValue.String())
}

// RecordSapnetweaverQueueCountDataPoint adds a data point to sapnetweaver.queue.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverQueueCountDataPoint(ts pcommon.Timestamp, val int64, wpTypeAttributeValue string) {
	mb.metricSapnetweaverQueueCount.recordDataPoint(mb.startTime, ts, val, wpTypeAttributeValue)
}

// RecordSapnetweaverQueueMaxCountDataPoint adds a data point to sapnetweaver.queue_max.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverQueueMaxCountDataPoint(ts pcommon.Timestamp, val int64, wpTypeAttributeValue string) {
	mb.metricSapnetweaverQueueMaxCount.recordDataPoint(mb.startTime, ts, val, wpTypeAttributeValue)
}

// RecordSapnetweaverQueuePeakCountDataPoint adds a data point to sapnetweaver.queue_peak.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverQueuePeakCountDataPoint(ts pcommon.Timestamp, val int64, wpTypeAttributeValue string) {
	mb.metricSapnetweaverQueuePeakCount.recordDataPoint(mb.startTime, ts, val, wpTypeAttributeValue)
}

// RecordSapnetweaverRequestCountDataPoint adds a data point to sapnetweaver.request.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverRequestCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverRequestCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverRequestCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverRequestTimeoutCountDataPoint adds a data point to sapnetweaver.request.timeout.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverRequestTimeoutCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverRequestTimeoutCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverRequestTimeoutCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverResponseDurationDataPoint adds a data point to sapnetweaver.response.duration metric.
func (mb *MetricsBuilder) RecordSapnetweaverResponseDurationDataPoint(ts pcommon.Timestamp, inputVal string, responseTypeAttributeValue AttributeResponseType) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverResponseDuration, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverResponseDuration.recordDataPoint(mb.startTime, ts, val, responseTypeAttributeValue.String())
	return nil
}

// RecordSapnetweaverSessionCountDataPoint adds a data point to sapnetweaver.session.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverSessionCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverSessionCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverSessionCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverSessionsBrowserCountDataPoint adds a data point to sapnetweaver.sessions.browser.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverSessionsBrowserCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverSessionsBrowserCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverSessionsBrowserCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverSessionsEjbCountDataPoint adds a data point to sapnetweaver.sessions.ejb.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverSessionsEjbCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverSessionsEjbCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverSessionsEjbCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverSessionsHTTPCountDataPoint adds a data point to sapnetweaver.sessions.http.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverSessionsHTTPCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverSessionsHTTPCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverSessionsHTTPCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverSessionsSecurityCountDataPoint adds a data point to sapnetweaver.sessions.security.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverSessionsSecurityCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverSessionsSecurityCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverSessionsSecurityCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverSessionsWebCountDataPoint adds a data point to sapnetweaver.sessions.web.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverSessionsWebCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverSessionsWebCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverSessionsWebCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverShortDumpsRateDataPoint adds a data point to sapnetweaver.short_dumps.rate metric.
func (mb *MetricsBuilder) RecordSapnetweaverShortDumpsRateDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverShortDumpsRate, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverShortDumpsRate.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverSpoolRequestErrorCountDataPoint adds a data point to sapnetweaver.spool.request.error.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverSpoolRequestErrorCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverSpoolRequestErrorCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverSpoolRequestErrorCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverSystemInstanceAvailabilityDataPoint adds a data point to sapnetweaver.system.instance_availability metric.
func (mb *MetricsBuilder) RecordSapnetweaverSystemInstanceAvailabilityDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, instanceNumberAttributeValue int64, featureAttributeValue string, controlStateAttributeValue AttributeControlState) {
	mb.metricSapnetweaverSystemInstanceAvailability.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, instanceNumberAttributeValue, featureAttributeValue, controlStateAttributeValue.String())
}

// RecordSapnetweaverWorkProcessActiveCountDataPoint adds a data point to sapnetweaver.work_process.active.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverWorkProcessActiveCountDataPoint(ts pcommon.Timestamp, val int64, instanceAttributeValue string, wpTypeAttributeValue string, wpStatusAttributeValue string) {
	mb.metricSapnetweaverWorkProcessActiveCount.recordDataPoint(mb.startTime, ts, val, instanceAttributeValue, wpTypeAttributeValue, wpStatusAttributeValue)
}

// RecordSapnetweaverWorkProcessJobAbortedCountDataPoint adds a data point to sapnetweaver.work_process.job.aborted.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverWorkProcessJobAbortedCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverWorkProcessJobAbortedCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverWorkProcessJobAbortedCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}
