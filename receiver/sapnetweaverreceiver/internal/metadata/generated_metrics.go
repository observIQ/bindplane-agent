// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"fmt"
	"strconv"
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/confmap"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`

	enabledSetByUser bool
}

func (ms *MetricSettings) Unmarshal(parser *confmap.Conf) error {
	if parser == nil {
		return nil
	}
	err := parser.Unmarshal(ms, confmap.WithErrorUnused())
	if err != nil {
		return err
	}
	ms.enabledSetByUser = parser.IsSet("enabled")
	return nil
}

// MetricsSettings provides settings for sapnetweaverreceiver metrics.
type MetricsSettings struct {
	SapnetweaverAbapUpdateErrors    MetricSettings `mapstructure:"sapnetweaver.abap.update.errors"`
	SapnetweaverCacheEvictions      MetricSettings `mapstructure:"sapnetweaver.cache.evictions"`
	SapnetweaverCacheHits           MetricSettings `mapstructure:"sapnetweaver.cache.hits"`
	SapnetweaverConnectionErrors    MetricSettings `mapstructure:"sapnetweaver.connection.errors"`
	SapnetweaverHostCPUUtilization  MetricSettings `mapstructure:"sapnetweaver.host.cpu.utilization"`
	SapnetweaverHostSpoolListUsed   MetricSettings `mapstructure:"sapnetweaver.host.spool_list.used"`
	SapnetweaverIcmAvailability     MetricSettings `mapstructure:"sapnetweaver.icm_availability"`
	SapnetweaverJobAborted          MetricSettings `mapstructure:"sapnetweaver.job.aborted"`
	SapnetweaverMemoryConfigured    MetricSettings `mapstructure:"sapnetweaver.memory.configured"`
	SapnetweaverMemoryFree          MetricSettings `mapstructure:"sapnetweaver.memory.free"`
	SapnetweaverMemoryUsage         MetricSettings `mapstructure:"sapnetweaver.memory.usage"`
	SapnetweaverQueueCount          MetricSettings `mapstructure:"sapnetweaver.queue.count"`
	SapnetweaverQueuePeakCount      MetricSettings `mapstructure:"sapnetweaver.queue_peak.count"`
	SapnetweaverRequestCount        MetricSettings `mapstructure:"sapnetweaver.request.count"`
	SapnetweaverRequestTimeoutCount MetricSettings `mapstructure:"sapnetweaver.request.timeout.count"`
	SapnetweaverResponseDuration    MetricSettings `mapstructure:"sapnetweaver.response.duration"`
	SapnetweaverSessionCount        MetricSettings `mapstructure:"sapnetweaver.session.count"`
	SapnetweaverShortDumpsRate      MetricSettings `mapstructure:"sapnetweaver.short_dumps.rate"`
	SapnetweaverSystemAvailability  MetricSettings `mapstructure:"sapnetweaver.system.availability"`
	SapnetweaverSystemUtilization   MetricSettings `mapstructure:"sapnetweaver.system.utilization"`
	SapnetweaverWorkProcessesCount  MetricSettings `mapstructure:"sapnetweaver.work_processes.count"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		SapnetweaverAbapUpdateErrors: MetricSettings{
			Enabled: true,
		},
		SapnetweaverCacheEvictions: MetricSettings{
			Enabled: true,
		},
		SapnetweaverCacheHits: MetricSettings{
			Enabled: true,
		},
		SapnetweaverConnectionErrors: MetricSettings{
			Enabled: true,
		},
		SapnetweaverHostCPUUtilization: MetricSettings{
			Enabled: true,
		},
		SapnetweaverHostSpoolListUsed: MetricSettings{
			Enabled: true,
		},
		SapnetweaverIcmAvailability: MetricSettings{
			Enabled: true,
		},
		SapnetweaverJobAborted: MetricSettings{
			Enabled: true,
		},
		SapnetweaverMemoryConfigured: MetricSettings{
			Enabled: true,
		},
		SapnetweaverMemoryFree: MetricSettings{
			Enabled: true,
		},
		SapnetweaverMemoryUsage: MetricSettings{
			Enabled: true,
		},
		SapnetweaverQueueCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverQueuePeakCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverRequestCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverRequestTimeoutCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverResponseDuration: MetricSettings{
			Enabled: true,
		},
		SapnetweaverSessionCount: MetricSettings{
			Enabled: true,
		},
		SapnetweaverShortDumpsRate: MetricSettings{
			Enabled: true,
		},
		SapnetweaverSystemAvailability: MetricSettings{
			Enabled: true,
		},
		SapnetweaverSystemUtilization: MetricSettings{
			Enabled: true,
		},
		SapnetweaverWorkProcessesCount: MetricSettings{
			Enabled: true,
		},
	}
}

// ResourceAttributeSettings provides common settings for a particular metric.
type ResourceAttributeSettings struct {
	Enabled bool `mapstructure:"enabled"`

	enabledProvidedByUser bool
}

func (ras *ResourceAttributeSettings) Unmarshal(parser *confmap.Conf) error {
	if parser == nil {
		return nil
	}
	err := parser.Unmarshal(ras, confmap.WithErrorUnused())
	if err != nil {
		return err
	}
	ras.enabledProvidedByUser = parser.IsSet("enabled")
	return nil
}

// ResourceAttributesSettings provides settings for sapnetweaverreceiver metrics.
type ResourceAttributesSettings struct {
	SapnetweaverInstance ResourceAttributeSettings `mapstructure:"sapnetweaver.instance"`
	SapnetweaverNode     ResourceAttributeSettings `mapstructure:"sapnetweaver.node"`
}

func DefaultResourceAttributesSettings() ResourceAttributesSettings {
	return ResourceAttributesSettings{
		SapnetweaverInstance: ResourceAttributeSettings{
			Enabled: false,
		},
		SapnetweaverNode: ResourceAttributeSettings{
			Enabled: false,
		},
	}
}

// AttributeControlState specifies the a value control_state attribute.
type AttributeControlState int

const (
	_ AttributeControlState = iota
	AttributeControlStateGrey
	AttributeControlStateGreen
	AttributeControlStateYellow
	AttributeControlStateRed
)

// String returns the string representation of the AttributeControlState.
func (av AttributeControlState) String() string {
	switch av {
	case AttributeControlStateGrey:
		return "grey"
	case AttributeControlStateGreen:
		return "green"
	case AttributeControlStateYellow:
		return "yellow"
	case AttributeControlStateRed:
		return "red"
	}
	return ""
}

// MapAttributeControlState is a helper map of string to AttributeControlState attribute value.
var MapAttributeControlState = map[string]AttributeControlState{
	"grey":   AttributeControlStateGrey,
	"green":  AttributeControlStateGreen,
	"yellow": AttributeControlStateYellow,
	"red":    AttributeControlStateRed,
}

// AttributeResponseType specifies the a value response_type attribute.
type AttributeResponseType int

const (
	_ AttributeResponseType = iota
	AttributeResponseTypeTransaction
	AttributeResponseTypeDialog
	AttributeResponseTypeDialogRFC
	AttributeResponseTypeHttp
)

// String returns the string representation of the AttributeResponseType.
func (av AttributeResponseType) String() string {
	switch av {
	case AttributeResponseTypeTransaction:
		return "transaction"
	case AttributeResponseTypeDialog:
		return "dialog"
	case AttributeResponseTypeDialogRFC:
		return "dialogRFC"
	case AttributeResponseTypeHttp:
		return "http"
	}
	return ""
}

// MapAttributeResponseType is a helper map of string to AttributeResponseType attribute value.
var MapAttributeResponseType = map[string]AttributeResponseType{
	"transaction": AttributeResponseTypeTransaction,
	"dialog":      AttributeResponseTypeDialog,
	"dialogRFC":   AttributeResponseTypeDialogRFC,
	"http":        AttributeResponseTypeHttp,
}

type metricSapnetweaverAbapUpdateErrors struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.abap.update.errors metric with initial data.
func (m *metricSapnetweaverAbapUpdateErrors) init() {
	m.data.SetName("sapnetweaver.abap.update.errors")
	m.data.SetDescription("The amount of ABAP errors in update.")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSapnetweaverAbapUpdateErrors) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, controlStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("control_state", controlStateAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverAbapUpdateErrors) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverAbapUpdateErrors) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverAbapUpdateErrors(settings MetricSettings) metricSapnetweaverAbapUpdateErrors {
	m := metricSapnetweaverAbapUpdateErrors{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverCacheEvictions struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.cache.evictions metric with initial data.
func (m *metricSapnetweaverCacheEvictions) init() {
	m.data.SetName("sapnetweaver.cache.evictions")
	m.data.SetDescription("The number of evicted entries.")
	m.data.SetUnit("{entr}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverCacheEvictions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverCacheEvictions) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverCacheEvictions) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverCacheEvictions(settings MetricSettings) metricSapnetweaverCacheEvictions {
	m := metricSapnetweaverCacheEvictions{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverCacheHits struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.cache.hits metric with initial data.
func (m *metricSapnetweaverCacheHits) init() {
	m.data.SetName("sapnetweaver.cache.hits")
	m.data.SetDescription("The cache hit percentage.")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSapnetweaverCacheHits) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverCacheHits) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverCacheHits) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverCacheHits(settings MetricSettings) metricSapnetweaverCacheHits {
	m := metricSapnetweaverCacheHits{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverConnectionErrors struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.connection.errors metric with initial data.
func (m *metricSapnetweaverConnectionErrors) init() {
	m.data.SetName("sapnetweaver.connection.errors")
	m.data.SetDescription("The amount of connection errors.")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverConnectionErrors) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverConnectionErrors) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverConnectionErrors) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverConnectionErrors(settings MetricSettings) metricSapnetweaverConnectionErrors {
	m := metricSapnetweaverConnectionErrors{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverHostCPUUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.host.cpu.utilization metric with initial data.
func (m *metricSapnetweaverHostCPUUtilization) init() {
	m.data.SetName("sapnetweaver.host.cpu.utilization")
	m.data.SetDescription("The CPU utilization percentage.")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSapnetweaverHostCPUUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverHostCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverHostCPUUtilization) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverHostCPUUtilization(settings MetricSettings) metricSapnetweaverHostCPUUtilization {
	m := metricSapnetweaverHostCPUUtilization{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverHostSpoolListUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.host.spool_list.used metric with initial data.
func (m *metricSapnetweaverHostSpoolListUsed) init() {
	m.data.SetName("sapnetweaver.host.spool_list.used")
	m.data.SetDescription("Host Spool List Used.")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverHostSpoolListUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverHostSpoolListUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverHostSpoolListUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverHostSpoolListUsed(settings MetricSettings) metricSapnetweaverHostSpoolListUsed {
	m := metricSapnetweaverHostSpoolListUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverIcmAvailability struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.icm_availability metric with initial data.
func (m *metricSapnetweaverIcmAvailability) init() {
	m.data.SetName("sapnetweaver.icm_availability")
	m.data.SetDescription("ICM Availability (color value from alert tree).")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSapnetweaverIcmAvailability) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, controlStateAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("control_state", controlStateAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverIcmAvailability) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverIcmAvailability) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverIcmAvailability(settings MetricSettings) metricSapnetweaverIcmAvailability {
	m := metricSapnetweaverIcmAvailability{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverJobAborted struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.job.aborted metric with initial data.
func (m *metricSapnetweaverJobAborted) init() {
	m.data.SetName("sapnetweaver.job.aborted")
	m.data.SetDescription("The amount of aborted jobs.")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverJobAborted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverJobAborted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverJobAborted) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverJobAborted(settings MetricSettings) metricSapnetweaverJobAborted {
	m := metricSapnetweaverJobAborted{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverMemoryConfigured struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.memory.configured metric with initial data.
func (m *metricSapnetweaverMemoryConfigured) init() {
	m.data.SetName("sapnetweaver.memory.configured")
	m.data.SetDescription("The amount of configured memory.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverMemoryConfigured) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverMemoryConfigured) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverMemoryConfigured) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverMemoryConfigured(settings MetricSettings) metricSapnetweaverMemoryConfigured {
	m := metricSapnetweaverMemoryConfigured{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverMemoryFree struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.memory.free metric with initial data.
func (m *metricSapnetweaverMemoryFree) init() {
	m.data.SetName("sapnetweaver.memory.free")
	m.data.SetDescription("The amount of free memory.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverMemoryFree) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverMemoryFree) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverMemoryFree) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverMemoryFree(settings MetricSettings) metricSapnetweaverMemoryFree {
	m := metricSapnetweaverMemoryFree{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverMemoryUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.memory.usage metric with initial data.
func (m *metricSapnetweaverMemoryUsage) init() {
	m.data.SetName("sapnetweaver.memory.usage")
	m.data.SetDescription("The memory usage percentage.")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSapnetweaverMemoryUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverMemoryUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverMemoryUsage) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverMemoryUsage(settings MetricSettings) metricSapnetweaverMemoryUsage {
	m := metricSapnetweaverMemoryUsage{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverQueueCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.queue.count metric with initial data.
func (m *metricSapnetweaverQueueCount) init() {
	m.data.SetName("sapnetweaver.queue.count")
	m.data.SetDescription("The queue length.")
	m.data.SetUnit("{entr}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverQueueCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverQueueCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverQueueCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverQueueCount(settings MetricSettings) metricSapnetweaverQueueCount {
	m := metricSapnetweaverQueueCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverQueuePeakCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.queue_peak.count metric with initial data.
func (m *metricSapnetweaverQueuePeakCount) init() {
	m.data.SetName("sapnetweaver.queue_peak.count")
	m.data.SetDescription("The peak queue length.")
	m.data.SetUnit("{entr}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverQueuePeakCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverQueuePeakCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverQueuePeakCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverQueuePeakCount(settings MetricSettings) metricSapnetweaverQueuePeakCount {
	m := metricSapnetweaverQueuePeakCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverRequestCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.request.count metric with initial data.
func (m *metricSapnetweaverRequestCount) init() {
	m.data.SetName("sapnetweaver.request.count")
	m.data.SetDescription("The amount of requests made.")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverRequestCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverRequestCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverRequestCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverRequestCount(settings MetricSettings) metricSapnetweaverRequestCount {
	m := metricSapnetweaverRequestCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverRequestTimeoutCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.request.timeout.count metric with initial data.
func (m *metricSapnetweaverRequestTimeoutCount) init() {
	m.data.SetName("sapnetweaver.request.timeout.count")
	m.data.SetDescription("The amount of timed out requests.")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverRequestTimeoutCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverRequestTimeoutCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverRequestTimeoutCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverRequestTimeoutCount(settings MetricSettings) metricSapnetweaverRequestTimeoutCount {
	m := metricSapnetweaverRequestTimeoutCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverResponseDuration struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.response.duration metric with initial data.
func (m *metricSapnetweaverResponseDuration) init() {
	m.data.SetName("sapnetweaver.response.duration")
	m.data.SetDescription("The response time duration.")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSapnetweaverResponseDuration) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, responseTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("response_type", responseTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverResponseDuration) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverResponseDuration) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverResponseDuration(settings MetricSettings) metricSapnetweaverResponseDuration {
	m := metricSapnetweaverResponseDuration{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverSessionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.session.count metric with initial data.
func (m *metricSapnetweaverSessionCount) init() {
	m.data.SetName("sapnetweaver.session.count")
	m.data.SetDescription("The amount of of sessions created.")
	m.data.SetUnit("")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverSessionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverSessionCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverSessionCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverSessionCount(settings MetricSettings) metricSapnetweaverSessionCount {
	m := metricSapnetweaverSessionCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverShortDumpsRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.short_dumps.rate metric with initial data.
func (m *metricSapnetweaverShortDumpsRate) init() {
	m.data.SetName("sapnetweaver.short_dumps.rate")
	m.data.SetDescription("The rate of Short Dumps.")
	m.data.SetUnit("{dumps/min}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverShortDumpsRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverShortDumpsRate) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverShortDumpsRate) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverShortDumpsRate(settings MetricSettings) metricSapnetweaverShortDumpsRate {
	m := metricSapnetweaverShortDumpsRate{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverSystemAvailability struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.system.availability metric with initial data.
func (m *metricSapnetweaverSystemAvailability) init() {
	m.data.SetName("sapnetweaver.system.availability")
	m.data.SetDescription("The system availability percentage.")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSapnetweaverSystemAvailability) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverSystemAvailability) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverSystemAvailability) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverSystemAvailability(settings MetricSettings) metricSapnetweaverSystemAvailability {
	m := metricSapnetweaverSystemAvailability{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverSystemUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.system.utilization metric with initial data.
func (m *metricSapnetweaverSystemUtilization) init() {
	m.data.SetName("sapnetweaver.system.utilization")
	m.data.SetDescription("The system utilization percentage.")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSapnetweaverSystemUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverSystemUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverSystemUtilization) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverSystemUtilization(settings MetricSettings) metricSapnetweaverSystemUtilization {
	m := metricSapnetweaverSystemUtilization{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSapnetweaverWorkProcessesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sapnetweaver.work_processes.count metric with initial data.
func (m *metricSapnetweaverWorkProcessesCount) init() {
	m.data.SetName("sapnetweaver.work_processes.count")
	m.data.SetDescription("The number of active work processes.")
	m.data.SetUnit("{work processes}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSapnetweaverWorkProcessesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSapnetweaverWorkProcessesCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSapnetweaverWorkProcessesCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSapnetweaverWorkProcessesCount(settings MetricSettings) metricSapnetweaverWorkProcessesCount {
	m := metricSapnetweaverWorkProcessesCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                             pcommon.Timestamp   // start time that will be applied to all recorded data points.
	metricsCapacity                       int                 // maximum observed number of metrics per resource.
	resourceCapacity                      int                 // maximum observed number of resource attributes.
	metricsBuffer                         pmetric.Metrics     // accumulates metrics data before emitting.
	buildInfo                             component.BuildInfo // contains version information
	resourceAttributesSettings            ResourceAttributesSettings
	metricSapnetweaverAbapUpdateErrors    metricSapnetweaverAbapUpdateErrors
	metricSapnetweaverCacheEvictions      metricSapnetweaverCacheEvictions
	metricSapnetweaverCacheHits           metricSapnetweaverCacheHits
	metricSapnetweaverConnectionErrors    metricSapnetweaverConnectionErrors
	metricSapnetweaverHostCPUUtilization  metricSapnetweaverHostCPUUtilization
	metricSapnetweaverHostSpoolListUsed   metricSapnetweaverHostSpoolListUsed
	metricSapnetweaverIcmAvailability     metricSapnetweaverIcmAvailability
	metricSapnetweaverJobAborted          metricSapnetweaverJobAborted
	metricSapnetweaverMemoryConfigured    metricSapnetweaverMemoryConfigured
	metricSapnetweaverMemoryFree          metricSapnetweaverMemoryFree
	metricSapnetweaverMemoryUsage         metricSapnetweaverMemoryUsage
	metricSapnetweaverQueueCount          metricSapnetweaverQueueCount
	metricSapnetweaverQueuePeakCount      metricSapnetweaverQueuePeakCount
	metricSapnetweaverRequestCount        metricSapnetweaverRequestCount
	metricSapnetweaverRequestTimeoutCount metricSapnetweaverRequestTimeoutCount
	metricSapnetweaverResponseDuration    metricSapnetweaverResponseDuration
	metricSapnetweaverSessionCount        metricSapnetweaverSessionCount
	metricSapnetweaverShortDumpsRate      metricSapnetweaverShortDumpsRate
	metricSapnetweaverSystemAvailability  metricSapnetweaverSystemAvailability
	metricSapnetweaverSystemUtilization   metricSapnetweaverSystemUtilization
	metricSapnetweaverWorkProcessesCount  metricSapnetweaverWorkProcessesCount
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

// WithResourceAttributesSettings sets ResourceAttributeSettings on the metrics builder.
func WithResourceAttributesSettings(ras ResourceAttributesSettings) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.resourceAttributesSettings = ras
	}
}

func NewMetricsBuilder(ms MetricsSettings, settings receiver.CreateSettings, options ...metricBuilderOption) *MetricsBuilder {
	if !ms.SapnetweaverWorkProcessesCount.enabledSetByUser {
		settings.Logger.Warn("[WARNING] Please set `enabled` field explicitly for `sapnetweaver.work_processes.count`: This metric will be disabled by default soon.")
	}
	mb := &MetricsBuilder{
		startTime:                             pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                         pmetric.NewMetrics(),
		buildInfo:                             settings.BuildInfo,
		resourceAttributesSettings:            DefaultResourceAttributesSettings(),
		metricSapnetweaverAbapUpdateErrors:    newMetricSapnetweaverAbapUpdateErrors(ms.SapnetweaverAbapUpdateErrors),
		metricSapnetweaverCacheEvictions:      newMetricSapnetweaverCacheEvictions(ms.SapnetweaverCacheEvictions),
		metricSapnetweaverCacheHits:           newMetricSapnetweaverCacheHits(ms.SapnetweaverCacheHits),
		metricSapnetweaverConnectionErrors:    newMetricSapnetweaverConnectionErrors(ms.SapnetweaverConnectionErrors),
		metricSapnetweaverHostCPUUtilization:  newMetricSapnetweaverHostCPUUtilization(ms.SapnetweaverHostCPUUtilization),
		metricSapnetweaverHostSpoolListUsed:   newMetricSapnetweaverHostSpoolListUsed(ms.SapnetweaverHostSpoolListUsed),
		metricSapnetweaverIcmAvailability:     newMetricSapnetweaverIcmAvailability(ms.SapnetweaverIcmAvailability),
		metricSapnetweaverJobAborted:          newMetricSapnetweaverJobAborted(ms.SapnetweaverJobAborted),
		metricSapnetweaverMemoryConfigured:    newMetricSapnetweaverMemoryConfigured(ms.SapnetweaverMemoryConfigured),
		metricSapnetweaverMemoryFree:          newMetricSapnetweaverMemoryFree(ms.SapnetweaverMemoryFree),
		metricSapnetweaverMemoryUsage:         newMetricSapnetweaverMemoryUsage(ms.SapnetweaverMemoryUsage),
		metricSapnetweaverQueueCount:          newMetricSapnetweaverQueueCount(ms.SapnetweaverQueueCount),
		metricSapnetweaverQueuePeakCount:      newMetricSapnetweaverQueuePeakCount(ms.SapnetweaverQueuePeakCount),
		metricSapnetweaverRequestCount:        newMetricSapnetweaverRequestCount(ms.SapnetweaverRequestCount),
		metricSapnetweaverRequestTimeoutCount: newMetricSapnetweaverRequestTimeoutCount(ms.SapnetweaverRequestTimeoutCount),
		metricSapnetweaverResponseDuration:    newMetricSapnetweaverResponseDuration(ms.SapnetweaverResponseDuration),
		metricSapnetweaverSessionCount:        newMetricSapnetweaverSessionCount(ms.SapnetweaverSessionCount),
		metricSapnetweaverShortDumpsRate:      newMetricSapnetweaverShortDumpsRate(ms.SapnetweaverShortDumpsRate),
		metricSapnetweaverSystemAvailability:  newMetricSapnetweaverSystemAvailability(ms.SapnetweaverSystemAvailability),
		metricSapnetweaverSystemUtilization:   newMetricSapnetweaverSystemUtilization(ms.SapnetweaverSystemUtilization),
		metricSapnetweaverWorkProcessesCount:  newMetricSapnetweaverWorkProcessesCount(ms.SapnetweaverWorkProcessesCount),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption func(ResourceAttributesSettings, pmetric.ResourceMetrics)

// WithSapnetweaverInstance sets provided value as "sapnetweaver.instance" attribute for current resource.
func WithSapnetweaverInstance(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.SapnetweaverInstance.Enabled {
			rm.Resource().Attributes().PutStr("sapnetweaver.instance", val)
		}
	}
}

// WithSapnetweaverNode sets provided value as "sapnetweaver.node" attribute for current resource.
func WithSapnetweaverNode(val string) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		if ras.SapnetweaverNode.Enabled {
			rm.Resource().Attributes().PutStr("sapnetweaver.node", val)
		}
	}
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(rmo ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/sapnetweaverreceiver")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricSapnetweaverAbapUpdateErrors.emit(ils.Metrics())
	mb.metricSapnetweaverCacheEvictions.emit(ils.Metrics())
	mb.metricSapnetweaverCacheHits.emit(ils.Metrics())
	mb.metricSapnetweaverConnectionErrors.emit(ils.Metrics())
	mb.metricSapnetweaverHostCPUUtilization.emit(ils.Metrics())
	mb.metricSapnetweaverHostSpoolListUsed.emit(ils.Metrics())
	mb.metricSapnetweaverIcmAvailability.emit(ils.Metrics())
	mb.metricSapnetweaverJobAborted.emit(ils.Metrics())
	mb.metricSapnetweaverMemoryConfigured.emit(ils.Metrics())
	mb.metricSapnetweaverMemoryFree.emit(ils.Metrics())
	mb.metricSapnetweaverMemoryUsage.emit(ils.Metrics())
	mb.metricSapnetweaverQueueCount.emit(ils.Metrics())
	mb.metricSapnetweaverQueuePeakCount.emit(ils.Metrics())
	mb.metricSapnetweaverRequestCount.emit(ils.Metrics())
	mb.metricSapnetweaverRequestTimeoutCount.emit(ils.Metrics())
	mb.metricSapnetweaverResponseDuration.emit(ils.Metrics())
	mb.metricSapnetweaverSessionCount.emit(ils.Metrics())
	mb.metricSapnetweaverShortDumpsRate.emit(ils.Metrics())
	mb.metricSapnetweaverSystemAvailability.emit(ils.Metrics())
	mb.metricSapnetweaverSystemUtilization.emit(ils.Metrics())
	mb.metricSapnetweaverWorkProcessesCount.emit(ils.Metrics())

	for _, op := range rmo {
		op(mb.resourceAttributesSettings, rm)
	}
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(rmo ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(rmo...)
	metrics := pmetric.NewMetrics()
	mb.metricsBuffer.MoveTo(metrics)
	return metrics
}

// RecordSapnetweaverAbapUpdateErrorsDataPoint adds a data point to sapnetweaver.abap.update.errors metric.
func (mb *MetricsBuilder) RecordSapnetweaverAbapUpdateErrorsDataPoint(ts pcommon.Timestamp, val int64, controlStateAttributeValue AttributeControlState) {
	mb.metricSapnetweaverAbapUpdateErrors.recordDataPoint(mb.startTime, ts, val, controlStateAttributeValue.String())
}

// RecordSapnetweaverCacheEvictionsDataPoint adds a data point to sapnetweaver.cache.evictions metric.
func (mb *MetricsBuilder) RecordSapnetweaverCacheEvictionsDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverCacheEvictions, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverCacheEvictions.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverCacheHitsDataPoint adds a data point to sapnetweaver.cache.hits metric.
func (mb *MetricsBuilder) RecordSapnetweaverCacheHitsDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverCacheHits, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverCacheHits.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverConnectionErrorsDataPoint adds a data point to sapnetweaver.connection.errors metric.
func (mb *MetricsBuilder) RecordSapnetweaverConnectionErrorsDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverConnectionErrors, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverConnectionErrors.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverHostCPUUtilizationDataPoint adds a data point to sapnetweaver.host.cpu.utilization metric.
func (mb *MetricsBuilder) RecordSapnetweaverHostCPUUtilizationDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverHostCPUUtilization, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverHostCPUUtilization.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverHostSpoolListUsedDataPoint adds a data point to sapnetweaver.host.spool_list.used metric.
func (mb *MetricsBuilder) RecordSapnetweaverHostSpoolListUsedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverHostSpoolListUsed, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverHostSpoolListUsed.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverIcmAvailabilityDataPoint adds a data point to sapnetweaver.icm_availability metric.
func (mb *MetricsBuilder) RecordSapnetweaverIcmAvailabilityDataPoint(ts pcommon.Timestamp, val int64, controlStateAttributeValue AttributeControlState) {
	mb.metricSapnetweaverIcmAvailability.recordDataPoint(mb.startTime, ts, val, controlStateAttributeValue.String())
}

// RecordSapnetweaverJobAbortedDataPoint adds a data point to sapnetweaver.job.aborted metric.
func (mb *MetricsBuilder) RecordSapnetweaverJobAbortedDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverJobAborted, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverJobAborted.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverMemoryConfiguredDataPoint adds a data point to sapnetweaver.memory.configured metric.
func (mb *MetricsBuilder) RecordSapnetweaverMemoryConfiguredDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSapnetweaverMemoryConfigured.recordDataPoint(mb.startTime, ts, val)
}

// RecordSapnetweaverMemoryFreeDataPoint adds a data point to sapnetweaver.memory.free metric.
func (mb *MetricsBuilder) RecordSapnetweaverMemoryFreeDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricSapnetweaverMemoryFree.recordDataPoint(mb.startTime, ts, val)
}

// RecordSapnetweaverMemoryUsageDataPoint adds a data point to sapnetweaver.memory.usage metric.
func (mb *MetricsBuilder) RecordSapnetweaverMemoryUsageDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverMemoryUsage, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverMemoryUsage.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverQueueCountDataPoint adds a data point to sapnetweaver.queue.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverQueueCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverQueueCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverQueueCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverQueuePeakCountDataPoint adds a data point to sapnetweaver.queue_peak.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverQueuePeakCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverQueuePeakCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverQueuePeakCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverRequestCountDataPoint adds a data point to sapnetweaver.request.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverRequestCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverRequestCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverRequestCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverRequestTimeoutCountDataPoint adds a data point to sapnetweaver.request.timeout.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverRequestTimeoutCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverRequestTimeoutCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverRequestTimeoutCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverResponseDurationDataPoint adds a data point to sapnetweaver.response.duration metric.
func (mb *MetricsBuilder) RecordSapnetweaverResponseDurationDataPoint(ts pcommon.Timestamp, inputVal string, responseTypeAttributeValue AttributeResponseType) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverResponseDuration, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverResponseDuration.recordDataPoint(mb.startTime, ts, val, responseTypeAttributeValue.String())
	return nil
}

// RecordSapnetweaverSessionCountDataPoint adds a data point to sapnetweaver.session.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverSessionCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverSessionCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverSessionCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverShortDumpsRateDataPoint adds a data point to sapnetweaver.short_dumps.rate metric.
func (mb *MetricsBuilder) RecordSapnetweaverShortDumpsRateDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverShortDumpsRate, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverShortDumpsRate.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverSystemAvailabilityDataPoint adds a data point to sapnetweaver.system.availability metric.
func (mb *MetricsBuilder) RecordSapnetweaverSystemAvailabilityDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverSystemAvailability, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverSystemAvailability.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverSystemUtilizationDataPoint adds a data point to sapnetweaver.system.utilization metric.
func (mb *MetricsBuilder) RecordSapnetweaverSystemUtilizationDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverSystemUtilization, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverSystemUtilization.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// RecordSapnetweaverWorkProcessesCountDataPoint adds a data point to sapnetweaver.work_processes.count metric.
func (mb *MetricsBuilder) RecordSapnetweaverWorkProcessesCountDataPoint(ts pcommon.Timestamp, inputVal string) error {
	val, err := strconv.ParseInt(inputVal, 10, 64)
	if err != nil {
		return fmt.Errorf("failed to parse int64 for SapnetweaverWorkProcessesCount, value was %s: %w", inputVal, err)
	}
	mb.metricSapnetweaverWorkProcessesCount.recordDataPoint(mb.startTime, ts, val)
	return nil
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}
