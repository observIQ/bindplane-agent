// /******************************************************************/
// /*********************** Worker Definition ************************/
// /******************************************************************/

// type worker struct {
// 	client     *workerClient
// 	endpoint   string            //api endpoint for this report
// 	token      string            //authorization token to access apis
// 	csvData    [][]string        //read the csv data directly into this to avoid downloading files
// 	csvColumns map[string]int    //the column numbers that the relevant data for this report are in
// 	reportData map[string]string //the data retrieved from the csv file for this report
// }

// // returns a new worker struct
// func newWorkerStruct(csvColumns map[string]int, token string, endpoint string) *worker {
// 	return &worker{
// 		endpoint:   endpoint,
// 		token:      token,
// 		csvColumns: csvColumns,
// 		client:     &workerClient{

// 		},
// 		reportData: map[string]string{},
// 	}
// }

// type workerClient struct {
// 	c      http.Client
// 	report reportPair
// }

// func (wc workerClient) GetReport() ([][]string, error) {

// }

// // retrieves csv data from endpoint and places data into csvData object
// func (w *worker) CSVData(httpC *http.Client) ([][]string, error) {
// 	req, err := http.NewRequest("GET", w.endpoint, nil)
// 	if err != nil {
// 		fmt.Println(err)
// 	}

// 	req.Header.Set("Authorization", w.token)
// 	resp, err := httpC.Do(req)
// 	if err != nil {
// 		fmt.Println(err)
// 	}
// 	defer resp.Body.Close()
// 	csvReader := csv.NewReader(resp.Body)

// 	//return csv data
// 	return csvReader.ReadAll()
// }

// // parses through csv data and creates metric points with data
// func (w *worker) parseData(httpC *http.Client) {
// 	data, err := w.CSVData(httpC)
// 	if err != nil {
// 		fmt.Println(err)
// 	}

// 	//only need last line of csv data
// 	line := data[len(w.csvData)-1]

// 	for k, v := range w.csvColumns {
// 		w.reportData[k] = line[v]
// 	}
// }
