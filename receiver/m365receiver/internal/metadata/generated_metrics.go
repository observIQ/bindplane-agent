// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/confmap"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`

	enabledSetByUser bool
}

func (ms *MetricSettings) Unmarshal(parser *confmap.Conf) error {
	if parser == nil {
		return nil
	}
	err := parser.Unmarshal(ms, confmap.WithErrorUnused())
	if err != nil {
		return err
	}
	ms.enabledSetByUser = parser.IsSet("enabled")
	return nil
}

// MetricsSettings provides settings for m365receiver metrics.
type MetricsSettings struct {
	M365OnedriveFilesActiveCount    MetricSettings `mapstructure:"m365.onedrive.files.active.count"`
	M365OnedriveFilesCount          MetricSettings `mapstructure:"m365.onedrive.files.count"`
	M365OnedriveUserActivityCount   MetricSettings `mapstructure:"m365.onedrive.user_activity.count"`
	M365OutlookAppUserCount         MetricSettings `mapstructure:"m365.outlook.app.user.count"`
	M365OutlookEmailActivityCount   MetricSettings `mapstructure:"m365.outlook.email_activity.count"`
	M365OutlookMailboxesActiveCount MetricSettings `mapstructure:"m365.outlook.mailboxes.active.count"`
	M365OutlookQuotaStatusCount     MetricSettings `mapstructure:"m365.outlook.quota_status.count"`
	M365OutlookStorageUsed          MetricSettings `mapstructure:"m365.outlook.storage.used"`
	M365SharepointFilesActiveCount  MetricSettings `mapstructure:"m365.sharepoint.files.active.count"`
	M365SharepointFilesCount        MetricSettings `mapstructure:"m365.sharepoint.files.count"`
	M365SharepointPagesUniqueCount  MetricSettings `mapstructure:"m365.sharepoint.pages.unique.count"`
	M365SharepointPagesViewedCount  MetricSettings `mapstructure:"m365.sharepoint.pages.viewed.count"`
	M365SharepointSiteStorageUsed   MetricSettings `mapstructure:"m365.sharepoint.site.storage.used"`
	M365SharepointSitesActiveCount  MetricSettings `mapstructure:"m365.sharepoint.sites.active.count"`
	M365TeamsCallsCount             MetricSettings `mapstructure:"m365.teams.calls.count"`
	M365TeamsDeviceUsageUsers       MetricSettings `mapstructure:"m365.teams.device_usage.users"`
	M365TeamsMeetingsCount          MetricSettings `mapstructure:"m365.teams.meetings.count"`
	M365TeamsMessagesPrivateCount   MetricSettings `mapstructure:"m365.teams.messages.private.count"`
	M365TeamsMessagesTeamCount      MetricSettings `mapstructure:"m365.teams.messages.team.count"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		M365OnedriveFilesActiveCount: MetricSettings{
			Enabled: true,
		},
		M365OnedriveFilesCount: MetricSettings{
			Enabled: true,
		},
		M365OnedriveUserActivityCount: MetricSettings{
			Enabled: true,
		},
		M365OutlookAppUserCount: MetricSettings{
			Enabled: true,
		},
		M365OutlookEmailActivityCount: MetricSettings{
			Enabled: true,
		},
		M365OutlookMailboxesActiveCount: MetricSettings{
			Enabled: true,
		},
		M365OutlookQuotaStatusCount: MetricSettings{
			Enabled: true,
		},
		M365OutlookStorageUsed: MetricSettings{
			Enabled: true,
		},
		M365SharepointFilesActiveCount: MetricSettings{
			Enabled: true,
		},
		M365SharepointFilesCount: MetricSettings{
			Enabled: true,
		},
		M365SharepointPagesUniqueCount: MetricSettings{
			Enabled: true,
		},
		M365SharepointPagesViewedCount: MetricSettings{
			Enabled: true,
		},
		M365SharepointSiteStorageUsed: MetricSettings{
			Enabled: true,
		},
		M365SharepointSitesActiveCount: MetricSettings{
			Enabled: true,
		},
		M365TeamsCallsCount: MetricSettings{
			Enabled: true,
		},
		M365TeamsDeviceUsageUsers: MetricSettings{
			Enabled: true,
		},
		M365TeamsMeetingsCount: MetricSettings{
			Enabled: true,
		},
		M365TeamsMessagesPrivateCount: MetricSettings{
			Enabled: true,
		},
		M365TeamsMessagesTeamCount: MetricSettings{
			Enabled: true,
		},
	}
}

// ResourceAttributeSettings provides common settings for a particular metric.
type ResourceAttributeSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// ResourceAttributesSettings provides settings for m365receiver metrics.
type ResourceAttributesSettings struct {
}

func DefaultResourceAttributesSettings() ResourceAttributesSettings {
	return ResourceAttributesSettings{}
}

// AttributeOnedriveActivity specifies the a value onedriveActivity attribute.
type AttributeOnedriveActivity int

const (
	_ AttributeOnedriveActivity = iota
	AttributeOnedriveActivityViewEdit
	AttributeOnedriveActivitySynced
	AttributeOnedriveActivityInternalShare
	AttributeOnedriveActivityExternalShare
)

// String returns the string representation of the AttributeOnedriveActivity.
func (av AttributeOnedriveActivity) String() string {
	switch av {
	case AttributeOnedriveActivityViewEdit:
		return "view_edit"
	case AttributeOnedriveActivitySynced:
		return "synced"
	case AttributeOnedriveActivityInternalShare:
		return "internal_share"
	case AttributeOnedriveActivityExternalShare:
		return "external_share"
	}
	return ""
}

// MapAttributeOnedriveActivity is a helper map of string to AttributeOnedriveActivity attribute value.
var MapAttributeOnedriveActivity = map[string]AttributeOnedriveActivity{
	"view_edit":      AttributeOnedriveActivityViewEdit,
	"synced":         AttributeOnedriveActivitySynced,
	"internal_share": AttributeOnedriveActivityInternalShare,
	"external_share": AttributeOnedriveActivityExternalShare,
}

// AttributeOutlookActivity specifies the a value outlookActivity attribute.
type AttributeOutlookActivity int

const (
	_ AttributeOutlookActivity = iota
	AttributeOutlookActivityRead
	AttributeOutlookActivitySent
	AttributeOutlookActivityReceived
)

// String returns the string representation of the AttributeOutlookActivity.
func (av AttributeOutlookActivity) String() string {
	switch av {
	case AttributeOutlookActivityRead:
		return "read"
	case AttributeOutlookActivitySent:
		return "sent"
	case AttributeOutlookActivityReceived:
		return "received"
	}
	return ""
}

// MapAttributeOutlookActivity is a helper map of string to AttributeOutlookActivity attribute value.
var MapAttributeOutlookActivity = map[string]AttributeOutlookActivity{
	"read":     AttributeOutlookActivityRead,
	"sent":     AttributeOutlookActivitySent,
	"received": AttributeOutlookActivityReceived,
}

// AttributeOutlookApps specifies the a value outlookApps attribute.
type AttributeOutlookApps int

const (
	_ AttributeOutlookApps = iota
	AttributeOutlookAppsPop3
	AttributeOutlookAppsImap4
	AttributeOutlookAppsSmtp
	AttributeOutlookAppsWindows
	AttributeOutlookAppsMac
	AttributeOutlookAppsWeb
	AttributeOutlookAppsMobile
	AttributeOutlookAppsOtherMobile
)

// String returns the string representation of the AttributeOutlookApps.
func (av AttributeOutlookApps) String() string {
	switch av {
	case AttributeOutlookAppsPop3:
		return "pop3"
	case AttributeOutlookAppsImap4:
		return "imap4"
	case AttributeOutlookAppsSmtp:
		return "smtp"
	case AttributeOutlookAppsWindows:
		return "windows"
	case AttributeOutlookAppsMac:
		return "mac"
	case AttributeOutlookAppsWeb:
		return "web"
	case AttributeOutlookAppsMobile:
		return "mobile"
	case AttributeOutlookAppsOtherMobile:
		return "other_mobile"
	}
	return ""
}

// MapAttributeOutlookApps is a helper map of string to AttributeOutlookApps attribute value.
var MapAttributeOutlookApps = map[string]AttributeOutlookApps{
	"pop3":         AttributeOutlookAppsPop3,
	"imap4":        AttributeOutlookAppsImap4,
	"smtp":         AttributeOutlookAppsSmtp,
	"windows":      AttributeOutlookAppsWindows,
	"mac":          AttributeOutlookAppsMac,
	"web":          AttributeOutlookAppsWeb,
	"mobile":       AttributeOutlookAppsMobile,
	"other_mobile": AttributeOutlookAppsOtherMobile,
}

// AttributeOutlookQuotas specifies the a value outlookQuotas attribute.
type AttributeOutlookQuotas int

const (
	_ AttributeOutlookQuotas = iota
	AttributeOutlookQuotasUnderLimit
	AttributeOutlookQuotasWarning
	AttributeOutlookQuotasSendProhibited
	AttributeOutlookQuotasSendReceiveProhibited
	AttributeOutlookQuotasIndeterminate
)

// String returns the string representation of the AttributeOutlookQuotas.
func (av AttributeOutlookQuotas) String() string {
	switch av {
	case AttributeOutlookQuotasUnderLimit:
		return "under_limit"
	case AttributeOutlookQuotasWarning:
		return "warning"
	case AttributeOutlookQuotasSendProhibited:
		return "send_prohibited"
	case AttributeOutlookQuotasSendReceiveProhibited:
		return "send_receive_prohibited"
	case AttributeOutlookQuotasIndeterminate:
		return "indeterminate"
	}
	return ""
}

// MapAttributeOutlookQuotas is a helper map of string to AttributeOutlookQuotas attribute value.
var MapAttributeOutlookQuotas = map[string]AttributeOutlookQuotas{
	"under_limit":             AttributeOutlookQuotasUnderLimit,
	"warning":                 AttributeOutlookQuotasWarning,
	"send_prohibited":         AttributeOutlookQuotasSendProhibited,
	"send_receive_prohibited": AttributeOutlookQuotasSendReceiveProhibited,
	"indeterminate":           AttributeOutlookQuotasIndeterminate,
}

// AttributeTeamsDevices specifies the a value teamsDevices attribute.
type AttributeTeamsDevices int

const (
	_ AttributeTeamsDevices = iota
	AttributeTeamsDevicesAndroid
	AttributeTeamsDevicesIOS
	AttributeTeamsDevicesMac
	AttributeTeamsDevicesWindows
	AttributeTeamsDevicesChromeOS
	AttributeTeamsDevicesLinux
	AttributeTeamsDevicesWeb
)

// String returns the string representation of the AttributeTeamsDevices.
func (av AttributeTeamsDevices) String() string {
	switch av {
	case AttributeTeamsDevicesAndroid:
		return "Android"
	case AttributeTeamsDevicesIOS:
		return "iOS"
	case AttributeTeamsDevicesMac:
		return "Mac"
	case AttributeTeamsDevicesWindows:
		return "Windows"
	case AttributeTeamsDevicesChromeOS:
		return "Chrome OS"
	case AttributeTeamsDevicesLinux:
		return "Linux"
	case AttributeTeamsDevicesWeb:
		return "Web"
	}
	return ""
}

// MapAttributeTeamsDevices is a helper map of string to AttributeTeamsDevices attribute value.
var MapAttributeTeamsDevices = map[string]AttributeTeamsDevices{
	"Android":   AttributeTeamsDevicesAndroid,
	"iOS":       AttributeTeamsDevicesIOS,
	"Mac":       AttributeTeamsDevicesMac,
	"Windows":   AttributeTeamsDevicesWindows,
	"Chrome OS": AttributeTeamsDevicesChromeOS,
	"Linux":     AttributeTeamsDevicesLinux,
	"Web":       AttributeTeamsDevicesWeb,
}

type metricM365OnedriveFilesActiveCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.onedrive.files.active.count metric with initial data.
func (m *metricM365OnedriveFilesActiveCount) init() {
	m.data.SetName("m365.onedrive.files.active.count")
	m.data.SetDescription("The number of active files across the OneDrive in the last 7 days.")
	m.data.SetUnit("{files}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricM365OnedriveFilesActiveCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365OnedriveFilesActiveCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365OnedriveFilesActiveCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365OnedriveFilesActiveCount(settings MetricSettings) metricM365OnedriveFilesActiveCount {
	m := metricM365OnedriveFilesActiveCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricM365OnedriveFilesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.onedrive.files.count metric with initial data.
func (m *metricM365OnedriveFilesCount) init() {
	m.data.SetName("m365.onedrive.files.count")
	m.data.SetDescription("The number of total files across the OneDrive for the last 7 days.")
	m.data.SetUnit("{files}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricM365OnedriveFilesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365OnedriveFilesCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365OnedriveFilesCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365OnedriveFilesCount(settings MetricSettings) metricM365OnedriveFilesCount {
	m := metricM365OnedriveFilesCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricM365OnedriveUserActivityCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.onedrive.user_activity.count metric with initial data.
func (m *metricM365OnedriveUserActivityCount) init() {
	m.data.SetName("m365.onedrive.user_activity.count")
	m.data.SetDescription("The number of users who have interacted with a OneDrive file, by action, in the last 7 days.")
	m.data.SetUnit("{users}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricM365OnedriveUserActivityCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, onedriveActivityAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("activity", onedriveActivityAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365OnedriveUserActivityCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365OnedriveUserActivityCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365OnedriveUserActivityCount(settings MetricSettings) metricM365OnedriveUserActivityCount {
	m := metricM365OnedriveUserActivityCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricM365OutlookAppUserCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.outlook.app.user.count metric with initial data.
func (m *metricM365OutlookAppUserCount) init() {
	m.data.SetName("m365.outlook.app.user.count")
	m.data.SetDescription("The number of unique users per app over the period of time in the organization Outlook in the last 7 days.")
	m.data.SetUnit("{users}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricM365OutlookAppUserCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, outlookAppsAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("app", outlookAppsAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365OutlookAppUserCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365OutlookAppUserCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365OutlookAppUserCount(settings MetricSettings) metricM365OutlookAppUserCount {
	m := metricM365OutlookAppUserCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricM365OutlookEmailActivityCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.outlook.email_activity.count metric with initial data.
func (m *metricM365OutlookEmailActivityCount) init() {
	m.data.SetName("m365.outlook.email_activity.count")
	m.data.SetDescription("The number of email actions by members over the period of time in the organization Outlook.")
	m.data.SetUnit("{emails}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricM365OutlookEmailActivityCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, outlookActivityAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("activity", outlookActivityAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365OutlookEmailActivityCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365OutlookEmailActivityCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365OutlookEmailActivityCount(settings MetricSettings) metricM365OutlookEmailActivityCount {
	m := metricM365OutlookEmailActivityCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricM365OutlookMailboxesActiveCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.outlook.mailboxes.active.count metric with initial data.
func (m *metricM365OutlookMailboxesActiveCount) init() {
	m.data.SetName("m365.outlook.mailboxes.active.count")
	m.data.SetDescription("The number of mailboxes that have been active each day in the organization for the last 7 days.")
	m.data.SetUnit("{mailboxes}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricM365OutlookMailboxesActiveCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365OutlookMailboxesActiveCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365OutlookMailboxesActiveCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365OutlookMailboxesActiveCount(settings MetricSettings) metricM365OutlookMailboxesActiveCount {
	m := metricM365OutlookMailboxesActiveCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricM365OutlookQuotaStatusCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.outlook.quota_status.count metric with initial data.
func (m *metricM365OutlookQuotaStatusCount) init() {
	m.data.SetName("m365.outlook.quota_status.count")
	m.data.SetDescription("The number of mailboxes in the various quota statuses over the period of time in the org in the last 7 days.")
	m.data.SetUnit("{mailboxes}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricM365OutlookQuotaStatusCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, outlookQuotasAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("state", outlookQuotasAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365OutlookQuotaStatusCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365OutlookQuotaStatusCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365OutlookQuotaStatusCount(settings MetricSettings) metricM365OutlookQuotaStatusCount {
	m := metricM365OutlookQuotaStatusCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricM365OutlookStorageUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.outlook.storage.used metric with initial data.
func (m *metricM365OutlookStorageUsed) init() {
	m.data.SetName("m365.outlook.storage.used")
	m.data.SetDescription("The amount of storage used in Outlook by the organization in the last 7 days.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricM365OutlookStorageUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365OutlookStorageUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365OutlookStorageUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365OutlookStorageUsed(settings MetricSettings) metricM365OutlookStorageUsed {
	m := metricM365OutlookStorageUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricM365SharepointFilesActiveCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.sharepoint.files.active.count metric with initial data.
func (m *metricM365SharepointFilesActiveCount) init() {
	m.data.SetName("m365.sharepoint.files.active.count")
	m.data.SetDescription("The number of active files across all sites in the last 7 days.")
	m.data.SetUnit("{files}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricM365SharepointFilesActiveCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365SharepointFilesActiveCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365SharepointFilesActiveCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365SharepointFilesActiveCount(settings MetricSettings) metricM365SharepointFilesActiveCount {
	m := metricM365SharepointFilesActiveCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricM365SharepointFilesCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.sharepoint.files.count metric with initial data.
func (m *metricM365SharepointFilesCount) init() {
	m.data.SetName("m365.sharepoint.files.count")
	m.data.SetDescription("The number of total files across all sites in the last 7 days.")
	m.data.SetUnit("{files}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricM365SharepointFilesCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365SharepointFilesCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365SharepointFilesCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365SharepointFilesCount(settings MetricSettings) metricM365SharepointFilesCount {
	m := metricM365SharepointFilesCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricM365SharepointPagesUniqueCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.sharepoint.pages.unique.count metric with initial data.
func (m *metricM365SharepointPagesUniqueCount) init() {
	m.data.SetName("m365.sharepoint.pages.unique.count")
	m.data.SetDescription("The number of unique views of pages across all sites in the last 7 days.")
	m.data.SetUnit("{views}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricM365SharepointPagesUniqueCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365SharepointPagesUniqueCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365SharepointPagesUniqueCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365SharepointPagesUniqueCount(settings MetricSettings) metricM365SharepointPagesUniqueCount {
	m := metricM365SharepointPagesUniqueCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricM365SharepointPagesViewedCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.sharepoint.pages.viewed.count metric with initial data.
func (m *metricM365SharepointPagesViewedCount) init() {
	m.data.SetName("m365.sharepoint.pages.viewed.count")
	m.data.SetDescription("The number of unique pages viewed across all sites in the last 7 days.")
	m.data.SetUnit("{pages}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricM365SharepointPagesViewedCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365SharepointPagesViewedCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365SharepointPagesViewedCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365SharepointPagesViewedCount(settings MetricSettings) metricM365SharepointPagesViewedCount {
	m := metricM365SharepointPagesViewedCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricM365SharepointSiteStorageUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.sharepoint.site.storage.used metric with initial data.
func (m *metricM365SharepointSiteStorageUsed) init() {
	m.data.SetName("m365.sharepoint.site.storage.used")
	m.data.SetDescription("The amount of storage used by all sites across SharePoint in the last 7 days.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricM365SharepointSiteStorageUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365SharepointSiteStorageUsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365SharepointSiteStorageUsed) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365SharepointSiteStorageUsed(settings MetricSettings) metricM365SharepointSiteStorageUsed {
	m := metricM365SharepointSiteStorageUsed{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricM365SharepointSitesActiveCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.sharepoint.sites.active.count metric with initial data.
func (m *metricM365SharepointSitesActiveCount) init() {
	m.data.SetName("m365.sharepoint.sites.active.count")
	m.data.SetDescription("The number of active sites across SharePoint in the last 7 days.")
	m.data.SetUnit("{sites}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricM365SharepointSitesActiveCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365SharepointSitesActiveCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365SharepointSitesActiveCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365SharepointSitesActiveCount(settings MetricSettings) metricM365SharepointSitesActiveCount {
	m := metricM365SharepointSitesActiveCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricM365TeamsCallsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.teams.calls.count metric with initial data.
func (m *metricM365TeamsCallsCount) init() {
	m.data.SetName("m365.teams.calls.count")
	m.data.SetDescription("The number of MS Teams calls from users in the organization in the last 7 days.")
	m.data.SetUnit("{calls}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricM365TeamsCallsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365TeamsCallsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365TeamsCallsCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365TeamsCallsCount(settings MetricSettings) metricM365TeamsCallsCount {
	m := metricM365TeamsCallsCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricM365TeamsDeviceUsageUsers struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.teams.device_usage.users metric with initial data.
func (m *metricM365TeamsDeviceUsageUsers) init() {
	m.data.SetName("m365.teams.device_usage.users")
	m.data.SetDescription("The number of unique users by device/platform that have used Teams in the last 7 days.")
	m.data.SetUnit("{users}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricM365TeamsDeviceUsageUsers) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, teamsDevicesAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("device", teamsDevicesAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365TeamsDeviceUsageUsers) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365TeamsDeviceUsageUsers) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365TeamsDeviceUsageUsers(settings MetricSettings) metricM365TeamsDeviceUsageUsers {
	m := metricM365TeamsDeviceUsageUsers{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricM365TeamsMeetingsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.teams.meetings.count metric with initial data.
func (m *metricM365TeamsMeetingsCount) init() {
	m.data.SetName("m365.teams.meetings.count")
	m.data.SetDescription("The number of MS Teams meetings for users in the organization in the last 7 days.")
	m.data.SetUnit("{meetings}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricM365TeamsMeetingsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365TeamsMeetingsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365TeamsMeetingsCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365TeamsMeetingsCount(settings MetricSettings) metricM365TeamsMeetingsCount {
	m := metricM365TeamsMeetingsCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricM365TeamsMessagesPrivateCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.teams.messages.private.count metric with initial data.
func (m *metricM365TeamsMessagesPrivateCount) init() {
	m.data.SetName("m365.teams.messages.private.count")
	m.data.SetDescription("The number of MS Teams private-messages sent by users in the organization in the last 7 days.")
	m.data.SetUnit("{messages}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricM365TeamsMessagesPrivateCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365TeamsMessagesPrivateCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365TeamsMessagesPrivateCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365TeamsMessagesPrivateCount(settings MetricSettings) metricM365TeamsMessagesPrivateCount {
	m := metricM365TeamsMessagesPrivateCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricM365TeamsMessagesTeamCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills m365.teams.messages.team.count metric with initial data.
func (m *metricM365TeamsMessagesTeamCount) init() {
	m.data.SetName("m365.teams.messages.team.count")
	m.data.SetDescription("The number of MS Teams team-messages sent by users in the organization in the last 7 days.")
	m.data.SetUnit("{messages}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricM365TeamsMessagesTeamCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricM365TeamsMessagesTeamCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricM365TeamsMessagesTeamCount) emit(metrics pmetric.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricM365TeamsMessagesTeamCount(settings MetricSettings) metricM365TeamsMessagesTeamCount {
	m := metricM365TeamsMessagesTeamCount{settings: settings}
	if settings.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilderConfig is a structural subset of an otherwise 1-1 copy of metadata.yaml
type MetricsBuilderConfig struct {
	Metrics            MetricsSettings            `mapstructure:"metrics"`
	ResourceAttributes ResourceAttributesSettings `mapstructure:"resource_attributes"`
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                             pcommon.Timestamp   // start time that will be applied to all recorded data points.
	metricsCapacity                       int                 // maximum observed number of metrics per resource.
	resourceCapacity                      int                 // maximum observed number of resource attributes.
	metricsBuffer                         pmetric.Metrics     // accumulates metrics data before emitting.
	buildInfo                             component.BuildInfo // contains version information
	resourceAttributesSettings            ResourceAttributesSettings
	metricM365OnedriveFilesActiveCount    metricM365OnedriveFilesActiveCount
	metricM365OnedriveFilesCount          metricM365OnedriveFilesCount
	metricM365OnedriveUserActivityCount   metricM365OnedriveUserActivityCount
	metricM365OutlookAppUserCount         metricM365OutlookAppUserCount
	metricM365OutlookEmailActivityCount   metricM365OutlookEmailActivityCount
	metricM365OutlookMailboxesActiveCount metricM365OutlookMailboxesActiveCount
	metricM365OutlookQuotaStatusCount     metricM365OutlookQuotaStatusCount
	metricM365OutlookStorageUsed          metricM365OutlookStorageUsed
	metricM365SharepointFilesActiveCount  metricM365SharepointFilesActiveCount
	metricM365SharepointFilesCount        metricM365SharepointFilesCount
	metricM365SharepointPagesUniqueCount  metricM365SharepointPagesUniqueCount
	metricM365SharepointPagesViewedCount  metricM365SharepointPagesViewedCount
	metricM365SharepointSiteStorageUsed   metricM365SharepointSiteStorageUsed
	metricM365SharepointSitesActiveCount  metricM365SharepointSitesActiveCount
	metricM365TeamsCallsCount             metricM365TeamsCallsCount
	metricM365TeamsDeviceUsageUsers       metricM365TeamsDeviceUsageUsers
	metricM365TeamsMeetingsCount          metricM365TeamsMeetingsCount
	metricM365TeamsMessagesPrivateCount   metricM365TeamsMessagesPrivateCount
	metricM365TeamsMessagesTeamCount      metricM365TeamsMessagesTeamCount
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func DefaultMetricsBuilderConfig() MetricsBuilderConfig {
	return MetricsBuilderConfig{
		Metrics:            DefaultMetricsSettings(),
		ResourceAttributes: DefaultResourceAttributesSettings(),
	}
}

func NewMetricsBuilderConfig(ms MetricsSettings, ras ResourceAttributesSettings) MetricsBuilderConfig {
	return MetricsBuilderConfig{
		Metrics:            ms,
		ResourceAttributes: ras,
	}
}

func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.CreateSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                             pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:                         pmetric.NewMetrics(),
		buildInfo:                             settings.BuildInfo,
		resourceAttributesSettings:            mbc.ResourceAttributes,
		metricM365OnedriveFilesActiveCount:    newMetricM365OnedriveFilesActiveCount(mbc.Metrics.M365OnedriveFilesActiveCount),
		metricM365OnedriveFilesCount:          newMetricM365OnedriveFilesCount(mbc.Metrics.M365OnedriveFilesCount),
		metricM365OnedriveUserActivityCount:   newMetricM365OnedriveUserActivityCount(mbc.Metrics.M365OnedriveUserActivityCount),
		metricM365OutlookAppUserCount:         newMetricM365OutlookAppUserCount(mbc.Metrics.M365OutlookAppUserCount),
		metricM365OutlookEmailActivityCount:   newMetricM365OutlookEmailActivityCount(mbc.Metrics.M365OutlookEmailActivityCount),
		metricM365OutlookMailboxesActiveCount: newMetricM365OutlookMailboxesActiveCount(mbc.Metrics.M365OutlookMailboxesActiveCount),
		metricM365OutlookQuotaStatusCount:     newMetricM365OutlookQuotaStatusCount(mbc.Metrics.M365OutlookQuotaStatusCount),
		metricM365OutlookStorageUsed:          newMetricM365OutlookStorageUsed(mbc.Metrics.M365OutlookStorageUsed),
		metricM365SharepointFilesActiveCount:  newMetricM365SharepointFilesActiveCount(mbc.Metrics.M365SharepointFilesActiveCount),
		metricM365SharepointFilesCount:        newMetricM365SharepointFilesCount(mbc.Metrics.M365SharepointFilesCount),
		metricM365SharepointPagesUniqueCount:  newMetricM365SharepointPagesUniqueCount(mbc.Metrics.M365SharepointPagesUniqueCount),
		metricM365SharepointPagesViewedCount:  newMetricM365SharepointPagesViewedCount(mbc.Metrics.M365SharepointPagesViewedCount),
		metricM365SharepointSiteStorageUsed:   newMetricM365SharepointSiteStorageUsed(mbc.Metrics.M365SharepointSiteStorageUsed),
		metricM365SharepointSitesActiveCount:  newMetricM365SharepointSitesActiveCount(mbc.Metrics.M365SharepointSitesActiveCount),
		metricM365TeamsCallsCount:             newMetricM365TeamsCallsCount(mbc.Metrics.M365TeamsCallsCount),
		metricM365TeamsDeviceUsageUsers:       newMetricM365TeamsDeviceUsageUsers(mbc.Metrics.M365TeamsDeviceUsageUsers),
		metricM365TeamsMeetingsCount:          newMetricM365TeamsMeetingsCount(mbc.Metrics.M365TeamsMeetingsCount),
		metricM365TeamsMessagesPrivateCount:   newMetricM365TeamsMessagesPrivateCount(mbc.Metrics.M365TeamsMessagesPrivateCount),
		metricM365TeamsMessagesTeamCount:      newMetricM365TeamsMessagesTeamCount(mbc.Metrics.M365TeamsMessagesTeamCount),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
	if mb.resourceCapacity < rm.Resource().Attributes().Len() {
		mb.resourceCapacity = rm.Resource().Attributes().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption func(ResourceAttributesSettings, pmetric.ResourceMetrics)

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return func(ras ResourceAttributesSettings, rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(rmo ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	rm.Resource().Attributes().EnsureCapacity(mb.resourceCapacity)
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/m365receiver")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricM365OnedriveFilesActiveCount.emit(ils.Metrics())
	mb.metricM365OnedriveFilesCount.emit(ils.Metrics())
	mb.metricM365OnedriveUserActivityCount.emit(ils.Metrics())
	mb.metricM365OutlookAppUserCount.emit(ils.Metrics())
	mb.metricM365OutlookEmailActivityCount.emit(ils.Metrics())
	mb.metricM365OutlookMailboxesActiveCount.emit(ils.Metrics())
	mb.metricM365OutlookQuotaStatusCount.emit(ils.Metrics())
	mb.metricM365OutlookStorageUsed.emit(ils.Metrics())
	mb.metricM365SharepointFilesActiveCount.emit(ils.Metrics())
	mb.metricM365SharepointFilesCount.emit(ils.Metrics())
	mb.metricM365SharepointPagesUniqueCount.emit(ils.Metrics())
	mb.metricM365SharepointPagesViewedCount.emit(ils.Metrics())
	mb.metricM365SharepointSiteStorageUsed.emit(ils.Metrics())
	mb.metricM365SharepointSitesActiveCount.emit(ils.Metrics())
	mb.metricM365TeamsCallsCount.emit(ils.Metrics())
	mb.metricM365TeamsDeviceUsageUsers.emit(ils.Metrics())
	mb.metricM365TeamsMeetingsCount.emit(ils.Metrics())
	mb.metricM365TeamsMessagesPrivateCount.emit(ils.Metrics())
	mb.metricM365TeamsMessagesTeamCount.emit(ils.Metrics())

	for _, op := range rmo {
		op(mb.resourceAttributesSettings, rm)
	}
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user settings, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(rmo ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(rmo...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordM365OnedriveFilesActiveCountDataPoint adds a data point to m365.onedrive.files.active.count metric.
func (mb *MetricsBuilder) RecordM365OnedriveFilesActiveCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricM365OnedriveFilesActiveCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordM365OnedriveFilesCountDataPoint adds a data point to m365.onedrive.files.count metric.
func (mb *MetricsBuilder) RecordM365OnedriveFilesCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricM365OnedriveFilesCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordM365OnedriveUserActivityCountDataPoint adds a data point to m365.onedrive.user_activity.count metric.
func (mb *MetricsBuilder) RecordM365OnedriveUserActivityCountDataPoint(ts pcommon.Timestamp, val int64, onedriveActivityAttributeValue AttributeOnedriveActivity) {
	mb.metricM365OnedriveUserActivityCount.recordDataPoint(mb.startTime, ts, val, onedriveActivityAttributeValue.String())
}

// RecordM365OutlookAppUserCountDataPoint adds a data point to m365.outlook.app.user.count metric.
func (mb *MetricsBuilder) RecordM365OutlookAppUserCountDataPoint(ts pcommon.Timestamp, val int64, outlookAppsAttributeValue AttributeOutlookApps) {
	mb.metricM365OutlookAppUserCount.recordDataPoint(mb.startTime, ts, val, outlookAppsAttributeValue.String())
}

// RecordM365OutlookEmailActivityCountDataPoint adds a data point to m365.outlook.email_activity.count metric.
func (mb *MetricsBuilder) RecordM365OutlookEmailActivityCountDataPoint(ts pcommon.Timestamp, val int64, outlookActivityAttributeValue AttributeOutlookActivity) {
	mb.metricM365OutlookEmailActivityCount.recordDataPoint(mb.startTime, ts, val, outlookActivityAttributeValue.String())
}

// RecordM365OutlookMailboxesActiveCountDataPoint adds a data point to m365.outlook.mailboxes.active.count metric.
func (mb *MetricsBuilder) RecordM365OutlookMailboxesActiveCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricM365OutlookMailboxesActiveCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordM365OutlookQuotaStatusCountDataPoint adds a data point to m365.outlook.quota_status.count metric.
func (mb *MetricsBuilder) RecordM365OutlookQuotaStatusCountDataPoint(ts pcommon.Timestamp, val int64, outlookQuotasAttributeValue AttributeOutlookQuotas) {
	mb.metricM365OutlookQuotaStatusCount.recordDataPoint(mb.startTime, ts, val, outlookQuotasAttributeValue.String())
}

// RecordM365OutlookStorageUsedDataPoint adds a data point to m365.outlook.storage.used metric.
func (mb *MetricsBuilder) RecordM365OutlookStorageUsedDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricM365OutlookStorageUsed.recordDataPoint(mb.startTime, ts, val)
}

// RecordM365SharepointFilesActiveCountDataPoint adds a data point to m365.sharepoint.files.active.count metric.
func (mb *MetricsBuilder) RecordM365SharepointFilesActiveCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricM365SharepointFilesActiveCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordM365SharepointFilesCountDataPoint adds a data point to m365.sharepoint.files.count metric.
func (mb *MetricsBuilder) RecordM365SharepointFilesCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricM365SharepointFilesCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordM365SharepointPagesUniqueCountDataPoint adds a data point to m365.sharepoint.pages.unique.count metric.
func (mb *MetricsBuilder) RecordM365SharepointPagesUniqueCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricM365SharepointPagesUniqueCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordM365SharepointPagesViewedCountDataPoint adds a data point to m365.sharepoint.pages.viewed.count metric.
func (mb *MetricsBuilder) RecordM365SharepointPagesViewedCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricM365SharepointPagesViewedCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordM365SharepointSiteStorageUsedDataPoint adds a data point to m365.sharepoint.site.storage.used metric.
func (mb *MetricsBuilder) RecordM365SharepointSiteStorageUsedDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricM365SharepointSiteStorageUsed.recordDataPoint(mb.startTime, ts, val)
}

// RecordM365SharepointSitesActiveCountDataPoint adds a data point to m365.sharepoint.sites.active.count metric.
func (mb *MetricsBuilder) RecordM365SharepointSitesActiveCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricM365SharepointSitesActiveCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordM365TeamsCallsCountDataPoint adds a data point to m365.teams.calls.count metric.
func (mb *MetricsBuilder) RecordM365TeamsCallsCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricM365TeamsCallsCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordM365TeamsDeviceUsageUsersDataPoint adds a data point to m365.teams.device_usage.users metric.
func (mb *MetricsBuilder) RecordM365TeamsDeviceUsageUsersDataPoint(ts pcommon.Timestamp, val int64, teamsDevicesAttributeValue AttributeTeamsDevices) {
	mb.metricM365TeamsDeviceUsageUsers.recordDataPoint(mb.startTime, ts, val, teamsDevicesAttributeValue.String())
}

// RecordM365TeamsMeetingsCountDataPoint adds a data point to m365.teams.meetings.count metric.
func (mb *MetricsBuilder) RecordM365TeamsMeetingsCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricM365TeamsMeetingsCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordM365TeamsMessagesPrivateCountDataPoint adds a data point to m365.teams.messages.private.count metric.
func (mb *MetricsBuilder) RecordM365TeamsMessagesPrivateCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricM365TeamsMessagesPrivateCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordM365TeamsMessagesTeamCountDataPoint adds a data point to m365.teams.messages.team.count metric.
func (mb *MetricsBuilder) RecordM365TeamsMessagesTeamCountDataPoint(ts pcommon.Timestamp, val int64) {
	mb.metricM365TeamsMessagesTeamCount.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}
