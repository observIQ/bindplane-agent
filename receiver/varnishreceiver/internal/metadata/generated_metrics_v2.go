// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/model/pdata"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for varnishreceiver metrics.
type MetricsSettings struct {
	VarnishBackendConnectionsCount MetricSettings `mapstructure:"varnish.backend.connections.count"`
	VarnishBackendRequestsCount    MetricSettings `mapstructure:"varnish.backend.requests.count"`
	VarnishCacheOperationsCount    MetricSettings `mapstructure:"varnish.cache.operations.count"`
	VarnishClientRequestsCount     MetricSettings `mapstructure:"varnish.client.requests.count"`
	VarnishObjectCount             MetricSettings `mapstructure:"varnish.object.count"`
	VarnishObjectExpiredCount      MetricSettings `mapstructure:"varnish.object.expired.count"`
	VarnishObjectMovedCount        MetricSettings `mapstructure:"varnish.object.moved.count"`
	VarnishObjectNukedCount        MetricSettings `mapstructure:"varnish.object.nuked.count"`
	VarnishSessionCount            MetricSettings `mapstructure:"varnish.session.count"`
	VarnishThreadOperationsCount   MetricSettings `mapstructure:"varnish.thread.operations.count"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		VarnishBackendConnectionsCount: MetricSettings{
			Enabled: true,
		},
		VarnishBackendRequestsCount: MetricSettings{
			Enabled: true,
		},
		VarnishCacheOperationsCount: MetricSettings{
			Enabled: true,
		},
		VarnishClientRequestsCount: MetricSettings{
			Enabled: true,
		},
		VarnishObjectCount: MetricSettings{
			Enabled: true,
		},
		VarnishObjectExpiredCount: MetricSettings{
			Enabled: true,
		},
		VarnishObjectMovedCount: MetricSettings{
			Enabled: true,
		},
		VarnishObjectNukedCount: MetricSettings{
			Enabled: true,
		},
		VarnishSessionCount: MetricSettings{
			Enabled: true,
		},
		VarnishThreadOperationsCount: MetricSettings{
			Enabled: true,
		},
	}
}

type metricVarnishBackendConnectionsCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills varnish.backend.connections.count metric with initial data.
func (m *metricVarnishBackendConnectionsCount) init() {
	m.data.SetName("varnish.backend.connections.count")
	m.data.SetDescription("The backend connection type count.")
	m.data.SetUnit("{connections}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVarnishBackendConnectionsCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, backendConnectionTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.BackendConnectionType, pdata.NewAttributeValueString(backendConnectionTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVarnishBackendConnectionsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVarnishBackendConnectionsCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVarnishBackendConnectionsCount(settings MetricSettings) metricVarnishBackendConnectionsCount {
	m := metricVarnishBackendConnectionsCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVarnishBackendRequestsCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills varnish.backend.requests.count metric with initial data.
func (m *metricVarnishBackendRequestsCount) init() {
	m.data.SetName("varnish.backend.requests.count")
	m.data.SetDescription("The backend requests count.")
	m.data.SetUnit("{requests}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVarnishBackendRequestsCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVarnishBackendRequestsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVarnishBackendRequestsCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVarnishBackendRequestsCount(settings MetricSettings) metricVarnishBackendRequestsCount {
	m := metricVarnishBackendRequestsCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVarnishCacheOperationsCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills varnish.cache.operations.count metric with initial data.
func (m *metricVarnishCacheOperationsCount) init() {
	m.data.SetName("varnish.cache.operations.count")
	m.data.SetDescription("The cache operation type count.")
	m.data.SetUnit("{operations}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVarnishCacheOperationsCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, cacheOperationsAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.CacheOperations, pdata.NewAttributeValueString(cacheOperationsAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVarnishCacheOperationsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVarnishCacheOperationsCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVarnishCacheOperationsCount(settings MetricSettings) metricVarnishCacheOperationsCount {
	m := metricVarnishCacheOperationsCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVarnishClientRequestsCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills varnish.client.requests.count metric with initial data.
func (m *metricVarnishClientRequestsCount) init() {
	m.data.SetName("varnish.client.requests.count")
	m.data.SetDescription("The client request count.")
	m.data.SetUnit("{requests}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVarnishClientRequestsCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, clientRequestsAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.ClientRequests, pdata.NewAttributeValueString(clientRequestsAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVarnishClientRequestsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVarnishClientRequestsCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVarnishClientRequestsCount(settings MetricSettings) metricVarnishClientRequestsCount {
	m := metricVarnishClientRequestsCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVarnishObjectCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills varnish.object.count metric with initial data.
func (m *metricVarnishObjectCount) init() {
	m.data.SetName("varnish.object.count")
	m.data.SetDescription("The HTTP objects in the cache count.")
	m.data.SetUnit("{objects}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVarnishObjectCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVarnishObjectCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVarnishObjectCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVarnishObjectCount(settings MetricSettings) metricVarnishObjectCount {
	m := metricVarnishObjectCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVarnishObjectExpiredCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills varnish.object.expired.count metric with initial data.
func (m *metricVarnishObjectExpiredCount) init() {
	m.data.SetName("varnish.object.expired.count")
	m.data.SetDescription("The expired objects from old age count.")
	m.data.SetUnit("{objects}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVarnishObjectExpiredCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVarnishObjectExpiredCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVarnishObjectExpiredCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVarnishObjectExpiredCount(settings MetricSettings) metricVarnishObjectExpiredCount {
	m := metricVarnishObjectExpiredCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVarnishObjectMovedCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills varnish.object.moved.count metric with initial data.
func (m *metricVarnishObjectMovedCount) init() {
	m.data.SetName("varnish.object.moved.count")
	m.data.SetDescription("The moved operations done on the LRU list count.")
	m.data.SetUnit("{objects}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVarnishObjectMovedCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVarnishObjectMovedCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVarnishObjectMovedCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVarnishObjectMovedCount(settings MetricSettings) metricVarnishObjectMovedCount {
	m := metricVarnishObjectMovedCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVarnishObjectNukedCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills varnish.object.nuked.count metric with initial data.
func (m *metricVarnishObjectNukedCount) init() {
	m.data.SetName("varnish.object.nuked.count")
	m.data.SetDescription("The objects that have been forcefully evicted from storage count.")
	m.data.SetUnit("{objects}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricVarnishObjectNukedCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVarnishObjectNukedCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVarnishObjectNukedCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVarnishObjectNukedCount(settings MetricSettings) metricVarnishObjectNukedCount {
	m := metricVarnishObjectNukedCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVarnishSessionCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills varnish.session.count metric with initial data.
func (m *metricVarnishSessionCount) init() {
	m.data.SetName("varnish.session.count")
	m.data.SetDescription("The session connection type count.")
	m.data.SetUnit("{connections}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVarnishSessionCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, sessionTypeAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.SessionType, pdata.NewAttributeValueString(sessionTypeAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVarnishSessionCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVarnishSessionCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVarnishSessionCount(settings MetricSettings) metricVarnishSessionCount {
	m := metricVarnishSessionCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVarnishThreadOperationsCount struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills varnish.thread.operations.count metric with initial data.
func (m *metricVarnishThreadOperationsCount) init() {
	m.data.SetName("varnish.thread.operations.count")
	m.data.SetDescription("The thread operation type count.")
	m.data.SetUnit("{operations}")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricVarnishThreadOperationsCount) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, threadOperationsAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.ThreadOperations, pdata.NewAttributeValueString(threadOperationsAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVarnishThreadOperationsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVarnishThreadOperationsCount) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVarnishThreadOperationsCount(settings MetricSettings) metricVarnishThreadOperationsCount {
	m := metricVarnishThreadOperationsCount{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                            pdata.Timestamp
	metricVarnishBackendConnectionsCount metricVarnishBackendConnectionsCount
	metricVarnishBackendRequestsCount    metricVarnishBackendRequestsCount
	metricVarnishCacheOperationsCount    metricVarnishCacheOperationsCount
	metricVarnishClientRequestsCount     metricVarnishClientRequestsCount
	metricVarnishObjectCount             metricVarnishObjectCount
	metricVarnishObjectExpiredCount      metricVarnishObjectExpiredCount
	metricVarnishObjectMovedCount        metricVarnishObjectMovedCount
	metricVarnishObjectNukedCount        metricVarnishObjectNukedCount
	metricVarnishSessionCount            metricVarnishSessionCount
	metricVarnishThreadOperationsCount   metricVarnishThreadOperationsCount
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pdata.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                            pdata.NewTimestampFromTime(time.Now()),
		metricVarnishBackendConnectionsCount: newMetricVarnishBackendConnectionsCount(settings.VarnishBackendConnectionsCount),
		metricVarnishBackendRequestsCount:    newMetricVarnishBackendRequestsCount(settings.VarnishBackendRequestsCount),
		metricVarnishCacheOperationsCount:    newMetricVarnishCacheOperationsCount(settings.VarnishCacheOperationsCount),
		metricVarnishClientRequestsCount:     newMetricVarnishClientRequestsCount(settings.VarnishClientRequestsCount),
		metricVarnishObjectCount:             newMetricVarnishObjectCount(settings.VarnishObjectCount),
		metricVarnishObjectExpiredCount:      newMetricVarnishObjectExpiredCount(settings.VarnishObjectExpiredCount),
		metricVarnishObjectMovedCount:        newMetricVarnishObjectMovedCount(settings.VarnishObjectMovedCount),
		metricVarnishObjectNukedCount:        newMetricVarnishObjectNukedCount(settings.VarnishObjectNukedCount),
		metricVarnishSessionCount:            newMetricVarnishSessionCount(settings.VarnishSessionCount),
		metricVarnishThreadOperationsCount:   newMetricVarnishThreadOperationsCount(settings.VarnishThreadOperationsCount),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// Emit appends generated metrics to a pdata.MetricsSlice and updates the internal state to be ready for recording
// another set of data points. This function will be doing all transformations required to produce metric representation
// defined in metadata and user settings, e.g. delta/cumulative translation.
func (mb *MetricsBuilder) Emit(metrics pdata.MetricSlice) {
	mb.metricVarnishBackendConnectionsCount.emit(metrics)
	mb.metricVarnishBackendRequestsCount.emit(metrics)
	mb.metricVarnishCacheOperationsCount.emit(metrics)
	mb.metricVarnishClientRequestsCount.emit(metrics)
	mb.metricVarnishObjectCount.emit(metrics)
	mb.metricVarnishObjectExpiredCount.emit(metrics)
	mb.metricVarnishObjectMovedCount.emit(metrics)
	mb.metricVarnishObjectNukedCount.emit(metrics)
	mb.metricVarnishSessionCount.emit(metrics)
	mb.metricVarnishThreadOperationsCount.emit(metrics)
}

// RecordVarnishBackendConnectionsCountDataPoint adds a data point to varnish.backend.connections.count metric.
func (mb *MetricsBuilder) RecordVarnishBackendConnectionsCountDataPoint(ts pdata.Timestamp, val int64, backendConnectionTypeAttributeValue string) {
	mb.metricVarnishBackendConnectionsCount.recordDataPoint(mb.startTime, ts, val, backendConnectionTypeAttributeValue)
}

// RecordVarnishBackendRequestsCountDataPoint adds a data point to varnish.backend.requests.count metric.
func (mb *MetricsBuilder) RecordVarnishBackendRequestsCountDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVarnishBackendRequestsCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordVarnishCacheOperationsCountDataPoint adds a data point to varnish.cache.operations.count metric.
func (mb *MetricsBuilder) RecordVarnishCacheOperationsCountDataPoint(ts pdata.Timestamp, val int64, cacheOperationsAttributeValue string) {
	mb.metricVarnishCacheOperationsCount.recordDataPoint(mb.startTime, ts, val, cacheOperationsAttributeValue)
}

// RecordVarnishClientRequestsCountDataPoint adds a data point to varnish.client.requests.count metric.
func (mb *MetricsBuilder) RecordVarnishClientRequestsCountDataPoint(ts pdata.Timestamp, val int64, clientRequestsAttributeValue string) {
	mb.metricVarnishClientRequestsCount.recordDataPoint(mb.startTime, ts, val, clientRequestsAttributeValue)
}

// RecordVarnishObjectCountDataPoint adds a data point to varnish.object.count metric.
func (mb *MetricsBuilder) RecordVarnishObjectCountDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVarnishObjectCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordVarnishObjectExpiredCountDataPoint adds a data point to varnish.object.expired.count metric.
func (mb *MetricsBuilder) RecordVarnishObjectExpiredCountDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVarnishObjectExpiredCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordVarnishObjectMovedCountDataPoint adds a data point to varnish.object.moved.count metric.
func (mb *MetricsBuilder) RecordVarnishObjectMovedCountDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVarnishObjectMovedCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordVarnishObjectNukedCountDataPoint adds a data point to varnish.object.nuked.count metric.
func (mb *MetricsBuilder) RecordVarnishObjectNukedCountDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVarnishObjectNukedCount.recordDataPoint(mb.startTime, ts, val)
}

// RecordVarnishSessionCountDataPoint adds a data point to varnish.session.count metric.
func (mb *MetricsBuilder) RecordVarnishSessionCountDataPoint(ts pdata.Timestamp, val int64, sessionTypeAttributeValue string) {
	mb.metricVarnishSessionCount.recordDataPoint(mb.startTime, ts, val, sessionTypeAttributeValue)
}

// RecordVarnishThreadOperationsCountDataPoint adds a data point to varnish.thread.operations.count metric.
func (mb *MetricsBuilder) RecordVarnishThreadOperationsCountDataPoint(ts pdata.Timestamp, val int64, threadOperationsAttributeValue string) {
	mb.metricVarnishThreadOperationsCount.recordDataPoint(mb.startTime, ts, val, threadOperationsAttributeValue)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pdata.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}

// NewMetricData creates new pdata.Metrics and sets the InstrumentationLibrary
// name on the ResourceMetrics.
func (mb *MetricsBuilder) NewMetricData() pdata.Metrics {
	md := pdata.NewMetrics()
	rm := md.ResourceMetrics().AppendEmpty()
	ilm := rm.InstrumentationLibraryMetrics().AppendEmpty()
	ilm.InstrumentationLibrary().SetName("otelcol/varnishreceiver")
	return md
}

// Attributes contains the possible metric attributes that can be used.
var Attributes = struct {
	// BackendConnectionType (The backend connection types.)
	BackendConnectionType string
	// CacheName (The varnish cache name.)
	CacheName string
	// CacheOperations (The cache operation types)
	CacheOperations string
	// ClientRequests (The client request types.)
	ClientRequests string
	// SessionType (The session connection types.)
	SessionType string
	// ThreadOperations (The thread operation types.)
	ThreadOperations string
}{
	"kind",
	"cache_name",
	"operation",
	"kind",
	"kind",
	"operation",
}

// A is an alias for Attributes.
var A = Attributes

// AttributeBackendConnectionType are the possible values that the attribute "backend_connection_type" can have.
var AttributeBackendConnectionType = struct {
	Success   string
	Recycle   string
	Reuse     string
	Fail      string
	Unhealthy string
	Busy      string
	Retry     string
}{
	"success",
	"recycle",
	"reuse",
	"fail",
	"unhealthy",
	"busy",
	"retry",
}

// AttributeCacheOperations are the possible values that the attribute "cache_operations" can have.
var AttributeCacheOperations = struct {
	Hit     string
	Miss    string
	HitPass string
}{
	"hit",
	"miss",
	"hit_pass",
}

// AttributeClientRequests are the possible values that the attribute "client_requests" can have.
var AttributeClientRequests = struct {
	Received string
	Dropped  string
}{
	"received",
	"dropped",
}

// AttributeSessionType are the possible values that the attribute "session_type" can have.
var AttributeSessionType = struct {
	Accepted string
	Dropped  string
	Failed   string
}{
	"accepted",
	"dropped",
	"failed",
}

// AttributeThreadOperations are the possible values that the attribute "thread_operations" can have.
var AttributeThreadOperations = struct {
	Created   string
	Destroyed string
	Failed    string
}{
	"created",
	"destroyed",
	"failed",
}
